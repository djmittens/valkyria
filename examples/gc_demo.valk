; Garbage Collection & Memory Management Demo
; ============================================
; Run: ./build/valk examples/gc_demo.valk
;
; What you‚Äôll see, with real numbers printed as we go:
; - Temporaries allocated in the scratch arena, then reclaimed at checkpoint
; - Scratch overflow falling back to heap, then GC reclaiming those bytes
; - Values evacuated from scratch into the GC heap when they escape via def
; - GC collections occur only at safe checkpoints (and can be triggered)
; - When the slab is saturated, allocations safely fall back to malloc

(load "src/prelude.valk")

; Small helpers to keep numbers readable
(fun {show-bytes label b}
  { println "%s: %ld bytes" label b })

; Clean output for better readability
(sys/log/set-level "error")

; Configure GC to run less frequently so we can control when it happens
(def {thr0} (mem/gc/threshold))
(def {hl0} (mem/heap/hard-limit))
(def {thr_old} (mem/gc/set-threshold hl0))

; Toggle heavy slab saturation phase (set to 1 to run it)
(def {run_heavy} 0)

; Capture baseline numbers
(def {arena_cap} (mem/arena/capacity))
(def {h0} (mem/heap/usage))
(def {a0} (mem/arena/usage))
(def {ck0} (mem/checkpoint/stats))      ; {count evacuated bytes fixed}

(println "")
(println "=== Memory Management: A Story in Real Numbers ===")
(println "")
(println "This demo shows how Valkyria manages memory using two regions:")
(println "  ‚Ä¢ A fast temporary space (%ld bytes) for values that don't need to stick around" arena_cap)
(println "  ‚Ä¢ A permanent heap for values you save with 'def'")
(println "")
(println "Watch the numbers change as we allocate, save, and collect garbage...")
(println "")
(println "Here's where we start:")
(mem/stats)

; ---------------------------------------------------------------------------
; Phase 1 ‚Äî Temporary values that disappear
; ---------------------------------------------------------------------------
(println "\n--- Chapter 1: The Vanishing Act ---")
(println "")
(println "When you calculate something temporary‚Äîlike (+ 1 2)‚Äîthe result needs memory,")
(println "but only for a moment. It would be wasteful to keep it forever.")
(println "")
(println "So Valkyria has a special %ld-byte temporary space." arena_cap)
(println "Values go there first. When your expression finishes, *poof*‚Äîthey vanish.")
(println "No garbage collection needed. Just instant cleanup.")
(println "")
(println "Let's see it happen...")

; In this expression we allocate a list that fits in the arena. We print
; live arena usage before/after to prove it grows here, then resets next expr.
(def {a1_start} (mem/arena/usage))
(do
  (def {tmp_len} (len (range 0 10000)))  ; ~10k cons cells
  (def {a1_after} (mem/arena/usage))
  (def {a1_growth} (- a1_after a1_start))
  (println "")
  (println "Inside the expression:")
  (println "  ‚Üí Created a %ld-element list" tmp_len)
  (println "  ‚Üí Scratch grew from %ld to %ld bytes (+%ld bytes)" a1_start a1_after a1_growth)
  (println "  ‚Üí This temporary data lives ONLY until the expression ends")
)

; Bonus: Show scratch at (or near) 100% BEFORE checkpoint (graphs include current usage).
; Allocate another ~10k list in the same expression, then call memory-stats inline.
(do
  (len (range 0 10000))
  (len (range 0 10000))
  (def {usage_now} (mem/arena/usage))
  (def {pct} (* 100 (/ usage_now arena_cap)))
  (println "")
  (println "Filling the arena to capacity:")
  (println "  ‚Üí Allocated more lists, scratch is now %ld / %ld bytes (%ld%% full)" usage_now arena_cap pct)
  (println "  ‚Üí Look for: SCRATCH ARENA [‚ñà‚ñà‚ñà] nearly full in the chart below")
  (mem/stats)
)

; Between expressions, memory gets reset
(def {a1_reset} (mem/arena/usage))
(def {reclaimed} (- a1_after a1_reset))
(println "")
(println "‚ú® And now... the magic trick!")
(println "")
(println "The expression finished. Watch what happens to that %ld bytes:" a1_after)
(println "  ...it vanished! Down to %ld bytes." a1_reset)
(println "")
(println "We just reclaimed %ld KB instantly, with zero cost." (/ reclaimed 1024))
(println "No scanning. No freeing. Just reset and done.")
(println "")
(println "Look at the memory chart‚Äîtemporary space is empty again:")
(mem/stats)

; ---------------------------------------------------------------------------
; Phase 2 ‚Äî What happens when temporary space runs out?
; ---------------------------------------------------------------------------

(println "\n--- Chapter 2: When the Fast Path Overflows ---")
(println "")
(println "That temporary space is only %ld bytes. What if you need more?" arena_cap)
(println "")
(println "Simple: values spill over into permanent heap space.")
(println "When the expression ends, those overflow values become garbage.")
(println "The garbage collector will clean them up eventually.")
(println "")
(println "Let's make that happen...")

(def {h2_before} (mem/heap/usage))
(do
  (def {big_tmp_len} (len (range 0 20000)))
  (println "")
  (println "Building a 20,000-element list...")
  (println "  (this is way more than %ld bytes can handle)" arena_cap)
)

(def {h2_after} (mem/heap/usage))
(def {heap_growth} (- h2_after h2_before))
(println "")
(println "Done. The permanent heap had to help out:")
(println "  ‚Üí Heap grew by %ld bytes (%ld KB)" heap_growth (/ heap_growth 1024))
(println "")
(println "The garbage collector will clean up those overflow values eventually.")
(println "")
(println "Look for the '[!] Overflow fallbacks' line in the memory chart:")
(mem/stats)

; ---------------------------------------------------------------------------
; Phase 3 ‚Äî Saving values permanently
; ---------------------------------------------------------------------------
(println "\n--- Chapter 3: Making Things Permanent ---")
(println "")
(println "So far, everything we've created disappeared after each expression.")
(println "But what if you want to keep something? That's what 'def' does.")
(println "")
(println "When you write (def {x} something), that value needs to stick around.")
(println "So it gets copied from temporary space into the permanent heap.")
(println "")
(println "Let's save 5 big lists and watch where they go...")

(def {ck_before} (mem/checkpoint/stats))
(def {h3_before} (mem/heap/usage))
(do
  (def {list1} (range 0 20000))
  (def {list2} (range 0 20000))
  (def {list3} (range 0 20000))
  (def {list4} (range 0 20000))
  (def {list5} (range 0 20000))
  (println "")
  (println "Saving 5 lists, each with 20,000 numbers...")
  (println "  (that's 100,000 values total)")
)

(def {ck_after} (mem/checkpoint/stats))
(def {h3_after} (mem/heap/usage))
(def {evac_count} (- (nth 2 ck_after) (nth 2 ck_before)))
(def {evac_bytes} (- (nth 3 ck_after) (nth 3 ck_before)))
(def {heap_growth} (- h3_after h3_before))
(println "")
(println "Done! Here's the journey those lists just took:")
(println "")
(println "  1. First, they were created in temporary space (fast!)")
(println "  2. Then 'def' marked them as 'I need to keep these'")
(println "  3. When the expression ended, they got copied to permanent heap")
(println "  4. Finally, temporary space was cleared out")
(println "")
(println "The numbers:")
(println "  ‚Üí Copied %ld values" evac_count)
(println "  ‚Üí That's %ld bytes (%ld MB) of data moved to permanent storage" evac_bytes (/ evac_bytes (* 1024 1024)))
(println "  ‚Üí Permanent heap grew by %ld MB" (/ heap_growth (* 1024 1024)))
(println "")
(println "Check the 'GC HEAP' section‚Äîit got much bigger:")
(mem/stats)

; ---------------------------------------------------------------------------
; GC Showcase ‚Äî Watching the garbage collector work
; ---------------------------------------------------------------------------
(println "\n--- Chapter 4: The Garbage Collector ---")
(println "")
(println "Now we have %ld MB in permanent heap. But not all of it is useful!" (/ (mem/heap/usage) (* 1024 1024)))
(println "Some values are garbage‚Äînobody references them anymore.")
(println "")
(println "The garbage collector's job: find the garbage and reclaim the memory.")
(println "Normally it runs when heap usage gets high. Let's trigger it now and watch...")

(def {heap_before_gc} (mem/heap/usage))
(def {thr_prev} (mem/gc/threshold))
(def {hu_now} (mem/heap/usage))
(def {thr_tmp} (+ hu_now 2048))
(def {thr_old2} (mem/gc/set-threshold thr_tmp))
(println "")
(println "(Lowering the GC threshold temporarily to %ld bytes...)" thr_tmp)
(do
  (def {slist}
       (map (\ {n} {"aaaaaaaaaaaaaaaaaaaaaaaa"}) (range 1 200)))
  (println "Creating 200 temporary strings to push heap past threshold...")
)

(def {heap_after_gc} (mem/heap/usage))
(mem/gc/set-threshold thr_prev)

(println "")
(println "üóëÔ∏è  The garbage collector just ran! Here's what it did:")
(println "")
(println "  Before GC:  %ld MB (%ld KB)" (/ heap_before_gc (* 1024 1024)) (/ heap_before_gc 1024))
(println "  After GC:   %ld MB (%ld KB)" (/ heap_after_gc (* 1024 1024)) (/ heap_after_gc 1024))
(println "")
(def {freed} (- heap_before_gc heap_after_gc))
(println "  Freed: %ld KB of garbage!" (/ freed 1024))
(println "")
(println "Look for 'GCs: 1' in the memory chart (the counter increased!):")
(mem/stats)

; ---------------------------------------------------------------------------
; Epilogue ‚Äî Closures work too
; ---------------------------------------------------------------------------
(println "\n--- Epilogue: Everything Still Works ---")
(println "")
(println "After all that copying and collecting, do closures still work?")
(println "Let's make 100 multiplier functions and see...")

(def {make-mult} (\ {n} {\ {x} {* x n}}))
(def {multipliers} (map make-mult (range 1 101)))
(println "")
(println "Testing: multiplier #1 times 7 = %ld" ((head multipliers) 7))
(println "Testing: multiplier #50 times 3 = %ld" ((nth 50 multipliers) 3))
(println "Testing: multiplier #100 times 5 = %ld" ((last multipliers) 5))
(println "")
(println "Perfect! Closures survived being copied and garbage collected.")

; Summary
(println "\n=== The Full Story, In Numbers ===")
(println "")
(def {ck_final} (mem/checkpoint/stats))
(def {hwm} (mem/arena/high-water))
(def {total_checkpoints} (nth 1 ck_final))
(def {total_evacuated} (nth 2 ck_final))
(def {total_evac_bytes} (nth 3 ck_final))
(println "Throughout this demo:")
(println "  ‚Ä¢ %ld checkpoints happened (between expressions)" total_checkpoints)
(println "  ‚Ä¢ %ld values were copied from temporary to permanent space" total_evacuated)
(println "  ‚Ä¢ %ld MB total were moved to keep things you saved with 'def'" (/ total_evac_bytes (* 1024 1024)))
(def {hwm_pct} (* 100 (/ hwm arena_cap)))
(println "  ‚Ä¢ Temporary space peaked at %ld bytes (%ld%% of capacity)" hwm hwm_pct)
(println "")
(println "And through it all, your data stayed safe and accessible.")
(println "")
(println "=== End of Demo ===")
(println "")
(println "Every number you saw was real, measured from the running system.")
(println "No estimates. No approximations. Just what actually happened.")
