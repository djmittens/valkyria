; HTTP/2 Web Server Demo - Full Feature Showcase
; ==============================================
; Run: ./build/valk examples/webserver_demo.valk
; Test: curl -k https://localhost:8443
;
; This demo showcases Valkyria's HTTP/2 server capabilities built on:
;   • libuv - Asynchronous I/O event loop
;   • nghttp2 - HTTP/2 protocol implementation
;   • OpenSSL - TLS/SSL encryption layer
;
; What you'll see demonstrated:
;   • Asynchronous I/O system initialization
;   • HTTP/2 server with TLS (self-signed certificates)
;   • Request handling with custom Lisp handler functions
;   • Event loop management
;   • Clean startup and shutdown messaging
;
; Architecture Overview:
; ─────────────────────
; The server runs in a background thread managed by libuv's event loop.
; When a request arrives:
;   1. Client connects via HTTPS
;   2. TLS handshake using self-signed certificate
;   3. HTTP/2 protocol negotiation (ALPN)
;   4. Request routed to your Lisp handler function
;   5. Handler returns response map {:status "..." :body "..."}
;   6. Response sent back to client
;
; The handler receives a request map containing request details.
; Currently, the request map structure is being finalized, but will include:
;   {:method "GET" :path "/api/users" :headers {...} :body "..."}

(load "src/prelude.valk")

; ╔════════════════════════════════════════════════════════════════════════════╗
; ║                    VALKYRIA HTTP/2 WEB SERVER DEMO                         ║
; ╚════════════════════════════════════════════════════════════════════════════╝

(println "")
(println "════════════════════════════════════════════════════════════════")
(println "  Valkyria HTTP/2 Web Server Demo")
(println "════════════════════════════════════════════════════════════════")
(println "")

; ──────────────────────────────────────────────────────────────────────────────
; STEP 1: Initialize the Asynchronous I/O System
; ──────────────────────────────────────────────────────────────────────────────
;
; The AIO (Async I/O) system provides the foundation for all asynchronous
; operations including HTTP/2 networking. It wraps libuv's event loop.
;
; Key Functions:
;   (aio/start)    - Creates and initializes a new AIO system
;   (aio/run sys)  - Runs the event loop (blocks until interrupted)
;
; Note: The REPL automatically creates a global 'aio' variable for convenience.
; In a standalone script, you would call (aio/start) yourself.

(println "→ Initializing Async I/O System")
(println "  • Using libuv for event loop management")
(println "  • Background thread handles all I/O operations")

; Use the REPL's pre-created AIO system (singleton pattern)
; If running outside REPL, you'd use: (def {sys} (aio/start))
(def {sys} aio)

(println "  ✓ AIO system ready")
(println "")

; ──────────────────────────────────────────────────────────────────────────────
; STEP 2: Define the Request Handler
; ──────────────────────────────────────────────────────────────────────────────
;
; The handler is a Lisp function that processes incoming HTTP requests.
;
; Handler Signature:
;   (lambda {request} ...)
;
; Parameters:
;   request - A map containing request details (structure being finalized)
;
; Return Value:
;   A map with response details:
;     {:status "200" :body "response content"}
;     {:status "404" :body "Not Found"}
;     {:status "500" :body "Internal Server Error"}
;
; The handler runs in the event loop thread, so it should:
;   • Return quickly (no blocking operations)
;   • Handle errors gracefully
;   • Always return a valid response map
;
; Future enhancements will support:
;   • Reading request method, path, headers, body
;   • Custom response headers
;   • Streaming responses
;   • Middleware composition

(println "→ Defining Request Handler")
(println "  • Handler receives request details")
(println "  • Returns response map {:status ... :body ...}")

; Create a comprehensive handler that demonstrates available features
(def {request-handler}
  (eval {\ {req} {
    ; Log incoming request (req structure is currently being finalized)
    (println "")
    (println "┌──────────────────────────────────────")
    (println "│ Incoming HTTP/2 Request")
    (println "├──────────────────────────────────────")
    (println "│ Request data:")
    (println (str req))
    (println "└──────────────────────────────────────")
    (println "")

    ; Build a simple HTML response
    (def {html-body} "<h1>Valkyria Lisp HTTP/2 Server</h1><p>Server is running! This response was generated by a Lisp handler function.</p><p><strong>Architecture:</strong> Valkyria Lisp + libuv + nghttp2 + OpenSSL</p>")

    ; Return response map
    ; Status must be a string (HTTP status code)
    ; Body can be any string content (HTML, JSON, plain text, etc.)
    {:status "200" :body html-body}
  }}))

(println "  ✓ Handler defined and ready")
(println "")

; ──────────────────────────────────────────────────────────────────────────────
; STEP 3: Start the HTTP/2 Server
; ──────────────────────────────────────────────────────────────────────────────
;
; Start an HTTP/2 server that listens for incoming HTTPS connections.
;
; Function Signature:
;   (http2/server-listen aio-system port handler-function)
;
; Parameters:
;   aio-system      - The AIO system from (aio/start) or the 'aio' global
;   port            - Port number to listen on (typically 8443 for HTTPS)
;   handler-function - Lisp function to handle requests
;
; TLS Certificates:
;   The server requires SSL certificates at:
;     • build/server.key - Private key
;     • build/server.crt - Self-signed certificate
;   These are auto-generated by the build system.
;
; Return Value:
;   Returns nil (server runs in background via event loop)
;
; Connection Flow:
;   1. Client connects to port 8443
;   2. TLS handshake (using self-signed cert)
;   3. ALPN negotiation (selects HTTP/2)
;   4. Request handling begins
;   5. Handler processes request
;   6. Response sent back
;   7. Connection closed cleanly

(println "→ Starting HTTP/2 Server")
(println "  • Binding to port 8443 (HTTPS)")
(println "  • Loading TLS certificates:")
(println "    - build/server.key (private key)")
(println "    - build/server.crt (self-signed certificate)")
(println "  • Attaching request handler")

; Start the server
; This returns immediately - the server runs in the background event loop
(http2/server-listen sys 8443 request-handler)

(println "  ✓ Server listening on https://localhost:8443")
(println "")

; ──────────────────────────────────────────────────────────────────────────────
; STEP 4: Display Usage Information
; ──────────────────────────────────────────────────────────────────────────────

(println "════════════════════════════════════════════════════════════════")
(println "  Server is Running!")
(println "════════════════════════════════════════════════════════════════")
(println "")
(println "The server is now accepting HTTP/2 requests over TLS.")
(println "")
(println "Test Commands:")
(println "  • Basic request:      curl -k https://localhost:8443")
(println "  • With headers:       curl -k -v https://localhost:8443")
(println "  • In browser:         https://localhost:8443")
(println "                        (accept security warning for self-signed cert)")
(println "")
(println "The -k flag tells curl to accept the self-signed certificate.")
(println "In production, you would use a certificate from a trusted CA.")
(println "")
(println "Press Ctrl+C to stop the server.")
(println "")
(println "════════════════════════════════════════════════════════════════")
(println "")

; ──────────────────────────────────────────────────────────────────────────────
; STEP 5: Run the Event Loop
; ──────────────────────────────────────────────────────────────────────────────
;
; Start the event loop and block until interrupted (Ctrl+C).
;
; Function Signature:
;   (aio/run aio-system)
;
; This function:
;   • Starts the libuv event loop in a background thread
;   • Processes all async I/O events (HTTP connections, timers, etc.)
;   • Blocks the main thread until interrupted
;   • Handles cleanup on shutdown
;
; When you press Ctrl+C:
;   1. Signal caught by the system
;   2. Event loop gracefully shuts down
;   3. Active connections are closed
;   4. Resources are freed
;   5. Program exits cleanly

; Run the event loop (blocks forever until Ctrl+C)
(aio/run sys)

; This line is never reached during normal operation (only after Ctrl+C)
(println "")
(println "Server stopped.")
