; HTTP/2 Web Server Demo - Full Feature Showcase
; ==============================================
; Run: ./build/valk examples/webserver_demo.valk
; Test: curl -k https://localhost:8443
;
; This demo showcases Valkyria's HTTP/2 server capabilities built on:
;   • libuv - Asynchronous I/O event loop
;   • nghttp2 - HTTP/2 protocol implementation
;   • OpenSSL - TLS/SSL encryption layer
;
; What you'll see demonstrated:
;   • Asynchronous I/O system initialization
;   • HTTP/2 server with TLS (self-signed certificates)
;   • Request handling with custom Lisp handler functions
;   • Event loop management
;   • Clean startup and shutdown messaging
;
; Architecture Overview:
; ─────────────────────
; The server runs in a background thread managed by libuv's event loop.
; When a request arrives:
;   1. Client connects via HTTPS
;   2. TLS handshake using self-signed certificate
;   3. HTTP/2 protocol negotiation (ALPN)
;   4. Request routed to your Lisp handler function
;   5. Handler returns response map {:status "..." :body "..."}
;   6. Response sent back to client
;
; The handler receives a request map containing request details.
; Currently, the request map structure is being finalized, but will include:
;   {:method "GET" :path "/api/users" :headers {...} :body "..."}

(load "src/prelude.valk")

; ╔════════════════════════════════════════════════════════════════════════════╗
; ║                    VALKYRIA HTTP/2 WEB SERVER DEMO                         ║
; ╚════════════════════════════════════════════════════════════════════════════╝

(println "")
(println "════════════════════════════════════════════════════════════════")
(println "  Valkyria HTTP/2 Web Server Demo")
(println "════════════════════════════════════════════════════════════════")
(println "")

; ──────────────────────────────────────────────────────────────────────────────
; STEP 1: Initialize the Asynchronous I/O System
; ──────────────────────────────────────────────────────────────────────────────
;
; The AIO (Async I/O) system provides the foundation for all asynchronous
; operations including HTTP/2 networking. It wraps libuv's event loop.
;
; Key Functions:
;   (aio/start)    - Creates and initializes a new AIO system
;   (aio/run sys)  - Runs the event loop (blocks until interrupted)
;
; Note: The REPL automatically creates a global 'aio' variable for convenience.
; In a standalone script, you would call (aio/start) yourself.

(println "→ Initializing Async I/O System")
(println "  • Using libuv for event loop management")
(println "  • Background thread handles all I/O operations")

; Use the REPL's pre-created AIO system (singleton pattern)
; If running outside REPL, you'd use: (def {sys} (aio/start))
(def {sys} aio)

(println "  ✓ AIO system ready")
(println "")

; ──────────────────────────────────────────────────────────────────────────────
; STEP 2: Define the Request Handler
; ──────────────────────────────────────────────────────────────────────────────
;
; The handler is a Lisp function that processes incoming HTTP requests.
;
; Handler Signature:
;   (lambda {request} ...)
;
; Parameters:
;   request - A map containing request details (structure being finalized)
;
; Return Value:
;   A map with response details:
;     {:status "200" :body "response content"}
;     {:status "404" :body "Not Found"}
;     {:status "500" :body "Internal Server Error"}
;
; The handler runs in the event loop thread, so it should:
;   • Return quickly (no blocking operations)
;   • Handle errors gracefully
;   • Always return a valid response map
;
; Future enhancements will support:
;   • Reading request method, path, headers, body
;   • Custom response headers
;   • Streaming responses
;   • Middleware composition

(println "→ Defining Request Handler")
(println "  • Handler receives request details")
(println "  • Returns response map {:status ... :body ...}")

; Valkyria favicon - a stylized V with wings (SVG)
(def {favicon-svg}
  (str "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">"
       "<defs>"
       "<linearGradient id=\"valkGrad\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\">"
       "<stop offset=\"0%\" style=\"stop-color:#6366f1\"/>"
       "<stop offset=\"50%\" style=\"stop-color:#8b5cf6\"/>"
       "<stop offset=\"100%\" style=\"stop-color:#d946ef\"/>"
       "</linearGradient>"
       "</defs>"
       "<circle cx=\"16\" cy=\"16\" r=\"15\" fill=\"#0f172a\"/>"
       "<path d=\"M8 8 L16 26 L24 8 L20 8 L16 18 L12 8 Z\" fill=\"url(#valkGrad)\"/>"
       "<path d=\"M4 10 L8 8 L10 12 Z\" fill=\"url(#valkGrad)\" opacity=\"0.7\"/>"
       "<path d=\"M28 10 L24 8 L22 12 Z\" fill=\"url(#valkGrad)\" opacity=\"0.7\"/>"
       "</svg>"))

; Main HTML page
(def {html-body}
  (str "<!DOCTYPE html>"
       "<html>"
       "<head>"
       "<meta charset=\"utf-8\">"
       "<title>Valkyria HTTP/2 Server</title>"
       "<link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\">"
       "<style>"
       "body { font-family: system-ui, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; background: #0f172a; color: #e2e8f0; }"
       "h1 { background: linear-gradient(135deg, #6366f1, #8b5cf6, #d946ef); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }"
       "p { color: #94a3b8; line-height: 1.6; }"
       "strong { color: #e2e8f0; }"
       "code { background: #1e293b; padding: 0.2rem 0.4rem; border-radius: 4px; font-family: monospace; }"
       ".hero { text-align: center; padding: 2rem 0; }"
       ".hero svg { width: 64px; height: 64px; margin-bottom: 1rem; }"
       "</style>"
       "</head>"
       "<body>"
       "<div class=\"hero\">"
       favicon-svg
       "<h1>Valkyria Lisp HTTP/2 Server</h1>"
       "</div>"
       "<p>Server is running! This response was generated by a Lisp handler function.</p>"
       "<p><strong>Architecture:</strong> Valkyria Lisp + libuv + nghttp2 + OpenSSL</p>"
       "<p><strong>Features:</strong> Async I/O, TLS encryption, HTTP/2 multiplexing</p>"
       "</body>"
       "</html>"))

; Create a comprehensive handler that demonstrates available features
(def {request-handler}
  (eval {\ {req} {
    ; Start timing
    (= {start} (time-us))

    ; Extract request info
    (= {method} (plist/get req (head {:method})))
    (= {path} (plist/get req (head {:path})))

    ; Route based on path
    (= {response} (select
      {(== path "/favicon.svg") `{:status "200" :content-type "image/svg+xml" :body ,favicon-svg}}
      {otherwise                `{:status "200" :content-type "text/html; charset=utf-8" :body ,html-body}}))

    ; Log request with timing
    (= {elapsed} (- (time-us) start))
    (printf "┌─ %s %s → %s (%dµs)\n│ %s\n└─\n" method path (plist/get response (head {:status})) elapsed (str req))

    response
  }}))

(println "  ✓ Handler defined and ready")
(println "")

; ──────────────────────────────────────────────────────────────────────────────
; STEP 3: Start the HTTP/2 Server
; ──────────────────────────────────────────────────────────────────────────────
;
; Start an HTTP/2 server that listens for incoming HTTPS connections.
;
; Function Signature:
;   (http2/server-listen aio-system port handler-function)
;
; Parameters:
;   aio-system      - The AIO system from (aio/start) or the 'aio' global
;   port            - Port number to listen on (typically 8443 for HTTPS)
;   handler-function - Lisp function to handle requests
;
; TLS Certificates:
;   The server requires SSL certificates at:
;     • build/server.key - Private key
;     • build/server.crt - Self-signed certificate
;   These are auto-generated by the build system.
;
; Return Value:
;   Returns nil (server runs in background via event loop)
;
; Connection Flow:
;   1. Client connects to port 8443
;   2. TLS handshake (using self-signed cert)
;   3. ALPN negotiation (selects HTTP/2)
;   4. Request handling begins
;   5. Handler processes request
;   6. Response sent back
;   7. Connection closed cleanly

(println "→ Starting HTTP/2 Server")
(println "  • Binding to port 8443 (HTTPS)")
(println "  • Loading TLS certificates:")
(println "    - build/server.key (private key)")
(println "    - build/server.crt (self-signed certificate)")
(println "  • Attaching request handler")

; Start the server
; This returns immediately - the server runs in the background event loop
(http2/server-listen sys 8443 request-handler)

(println "  ✓ Server listening on https://localhost:8443")
(println "")

; ──────────────────────────────────────────────────────────────────────────────
; STEP 4: Display Usage Information
; ──────────────────────────────────────────────────────────────────────────────

(println "════════════════════════════════════════════════════════════════")
(println "  Server is Running!")
(println "════════════════════════════════════════════════════════════════")
(println "")
(println "The server is now accepting HTTP/2 requests over TLS.")
(println "")
(println "Test Commands:")
(println "  • Basic request:      curl -k https://localhost:8443")
(println "  • With headers:       curl -k -v https://localhost:8443")
(println "  • In browser:         https://localhost:8443")
(println "                        (accept security warning for self-signed cert)")
(println "")
(println "The -k flag tells curl to accept the self-signed certificate.")
(println "In production, you would use a certificate from a trusted CA.")
(println "")
(println "Press Ctrl+C to stop the server.")
(println "")
(println "════════════════════════════════════════════════════════════════")
(println "")

; ──────────────────────────────────────────────────────────────────────────────
; STEP 5: Run the Event Loop
; ──────────────────────────────────────────────────────────────────────────────
;
; Start the event loop and block until interrupted (Ctrl+C).
;
; Function Signature:
;   (aio/run aio-system)
;
; This function:
;   • Starts the libuv event loop in a background thread
;   • Processes all async I/O events (HTTP connections, timers, etc.)
;   • Blocks the main thread until interrupted
;   • Handles cleanup on shutdown
;
; When you press Ctrl+C:
;   1. Signal caught by the system
;   2. Event loop gracefully shuts down
;   3. Active connections are closed
;   4. Resources are freed
;   5. Program exits cleanly

; Run the event loop (blocks forever until Ctrl+C)
(aio/run sys)

; This line is never reached during normal operation (only after Ctrl+C)
(println "")
(println "Server stopped.")
