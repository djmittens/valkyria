; Property-Based Testing for Valkyria
; Inspired by QuickCheck/ScalaCheck

; === Generators ===

(fun {gen/int lo hi} {(rand lo hi)})
(fun {gen/nat n} {(rand n)})
(fun {gen/bool} {(rand 2)})

(fun {gen/one-of lst} {
  (nth (+ 1 (rand (len lst))) lst)
})

(fun {gen/list-of gen-fn n} {
  (if (<= n 0)
    {nil}
    {(join (list (gen-fn)) (gen/list-of gen-fn (- n 1)))})
})

; === Property checking ===

(fun {prop/check name n prop-fn} {
  (prop/check-impl name n 0 prop-fn)
})

(fun {prop/check-impl name remaining failures prop-fn} {
  (if (<= remaining 0)
    {(if (> failures 0)
      {(error (str "property '" name "' failed " failures " times"))}
      {true})}
    {do
      (= {result} (prop-fn))
      (if (error? result)
        {(error (str "property '" name "' FAILED: " result))}
        {(if result
          {(prop/check-impl name (- remaining 1) failures prop-fn)}
          {(error (str "property '" name "' FAILED on iteration " (- remaining 1)))})})})
})

; === Typeclass Law Checkers ===

; Functor laws
; ops: {:map (f -> fa -> fb) :mk (a -> fa) :eq (fa -> fb -> Bool)}

(fun {laws/functor-identity ops gen-a} {do
  (= {fmap} (plist/get ops :map))
  (= {mk}   (plist/get ops :mk))
  (= {eq}   (plist/get ops :eq))
  (= {a} (gen-a))
  (= {fa} (mk a))
  (eq (fmap id fa) fa)
})

(fun {laws/functor-composition ops gen-a f g} {do
  (= {fmap} (plist/get ops :map))
  (= {mk}   (plist/get ops :mk))
  (= {eq}   (plist/get ops :eq))
  (= {a} (gen-a))
  (= {fa} (mk a))
  (eq (fmap g (fmap f fa)) (fmap (comp g f) fa))
})

; Applicative laws
; ops: {:pure (a -> fa) :ap (f(a->b) -> fa -> fb) :eq (fa -> fb -> Bool)}

(fun {laws/applicative-identity ops gen-a} {do
  (= {pure} (plist/get ops :pure))
  (= {ap}   (plist/get ops :ap))
  (= {eq}   (plist/get ops :eq))
  (= {a} (gen-a))
  (= {v} (pure a))
  (eq (ap (pure id) v) v)
})

(fun {laws/applicative-homomorphism ops gen-a f} {do
  (= {pure} (plist/get ops :pure))
  (= {ap}   (plist/get ops :ap))
  (= {eq}   (plist/get ops :eq))
  (= {a} (gen-a))
  (eq (ap (pure f) (pure a)) (pure (f a)))
})

; Monad laws
; ops: {:pure (a -> ma) :flat-map (ma -> (a -> mb) -> mb) :eq (ma -> mb -> Bool)}

(fun {laws/monad-left-identity ops gen-a f} {do
  (= {pure}     (plist/get ops :pure))
  (= {flat-map} (plist/get ops :flat-map))
  (= {eq}       (plist/get ops :eq))
  (= {a} (gen-a))
  (eq (flat-map (pure a) f) (f a))
})

(fun {laws/monad-right-identity ops gen-a} {do
  (= {pure}     (plist/get ops :pure))
  (= {flat-map} (plist/get ops :flat-map))
  (= {eq}       (plist/get ops :eq))
  (= {a} (gen-a))
  (= {m} (pure a))
  (eq (flat-map m pure) m)
})

(fun {laws/monad-associativity ops gen-a f g} {do
  (= {pure}     (plist/get ops :pure))
  (= {flat-map} (plist/get ops :flat-map))
  (= {eq}       (plist/get ops :eq))
  (= {a} (gen-a))
  (= {m} (pure a))
  (eq (flat-map (flat-map m f) g)
      (flat-map m (\ {x} {(flat-map (f x) g)})))
})

; Semiring laws (for Num with + and *)
; ops: {:add add-fn :mul mul-fn :zero zero :one one :eq eq-fn}

(fun {laws/semiring-additive-identity ops gen-a} {do
  (= {add}  (plist/get ops :add))
  (= {zero} (plist/get ops :zero))
  (= {eq}   (plist/get ops :eq))
  (= {a} (gen-a))
  (and (eq (add a zero) a)
       (eq (add zero a) a))
})

(fun {laws/semiring-multiplicative-identity ops gen-a} {do
  (= {mul} (plist/get ops :mul))
  (= {one} (plist/get ops :one))
  (= {eq}  (plist/get ops :eq))
  (= {a} (gen-a))
  (and (eq (mul a one) a)
       (eq (mul one a) a))
})

(fun {laws/semiring-additive-commutativity ops gen-a} {do
  (= {add} (plist/get ops :add))
  (= {eq}  (plist/get ops :eq))
  (= {a} (gen-a))
  (= {b} (gen-a))
  (eq (add a b) (add b a))
})

(fun {laws/semiring-additive-associativity ops gen-a} {do
  (= {add} (plist/get ops :add))
  (= {eq}  (plist/get ops :eq))
  (= {a} (gen-a))
  (= {b} (gen-a))
  (= {c} (gen-a))
  (eq (add (add a b) c) (add a (add b c)))
})

(fun {laws/semiring-multiplicative-associativity ops gen-a} {do
  (= {mul} (plist/get ops :mul))
  (= {eq}  (plist/get ops :eq))
  (= {a} (gen-a))
  (= {b} (gen-a))
  (= {c} (gen-a))
  (eq (mul (mul a b) c) (mul a (mul b c)))
})

(fun {laws/semiring-distributivity ops gen-a} {do
  (= {add} (plist/get ops :add))
  (= {mul} (plist/get ops :mul))
  (= {eq}  (plist/get ops :eq))
  (= {a} (gen-a))
  (= {b} (gen-a))
  (= {c} (gen-a))
  (and (eq (mul a (add b c)) (add (mul a b) (mul a c)))
       (eq (mul (add a b) c) (add (mul a c) (mul b c))))
})

; Bifunctor laws
; ops: {:bimap (p -> (a->c) -> (b->d) -> p') :mk (a -> b -> p) :eq (p -> p -> Bool)}

; bimap id id = id
(fun {laws/bifunctor-identity ops gen-a gen-b} {do
  (= {bimap} (plist/get ops :bimap))
  (= {mk}    (plist/get ops :mk))
  (= {eq}    (plist/get ops :eq))
  (= {a} (gen-a))
  (= {b} (gen-b))
  (= {p} (mk a b))
  (eq (bimap p id id) p)
})

; bimap (f . g) (h . k) = bimap f h . bimap g k
(fun {laws/bifunctor-composition ops gen-a gen-b f g h k} {do
  (= {bimap} (plist/get ops :bimap))
  (= {mk}    (plist/get ops :mk))
  (= {eq}    (plist/get ops :eq))
  (= {a} (gen-a))
  (= {b} (gen-b))
  (= {p} (mk a b))
  (eq (bimap p (comp f g) (comp h k))
      (bimap (bimap p g k) f h))
})

; Traversable laws (naturality is hard without polymorphism, test identity + composition)
; ops: {:traverse (list -> (a -> f b) -> f (list b)) :pure (a -> f a) :eq (fa -> fa -> Bool)}

; traverse list pure = pure list (identity law)
(fun {laws/traversable-identity ops gen-a gen-list-size} {do
  (= {traverse} (plist/get ops :traverse))
  (= {pure}     (plist/get ops :pure))
  (= {eq}       (plist/get ops :eq))
  (= {n} (gen-list-size))
  (= {l} (gen/list-of gen-a n))
  (eq (traverse l pure) (pure l))
})

(fun {laws/semiring-annihilation ops gen-a} {do
  (= {mul}  (plist/get ops :mul))
  (= {zero} (plist/get ops :zero))
  (= {eq}   (plist/get ops :eq))
  (= {a} (gen-a))
  (and (eq (mul a zero) zero)
       (eq (mul zero a) zero))
})
