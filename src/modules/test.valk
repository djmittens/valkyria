; Simple test framework for Valkyria

(def {*test-registry*} {})
(def {*test-passed*} 0)
(def {*test-failed*} 0)
(def {*test-suite-name*} "Valkyria Test Suite")

(fun {test/suite name} {
  (def {*test-suite-name*} name)
})

(fun {test/define name body} {
  (def {*test-registry*} (join *test-registry* (list (list name body))))
})

(fun {test/assert cond msg} {
  if cond
    {true}
    {error msg}
})

(fun {test/assert-eq expected actual msg} {
  (test/assert (== expected actual) msg)
})

; Tail-recursive helper to print n dots
(fun {*test-pad-dots-helper* n} {
  if (<= n 0)
    {true}
    {do (printf ".") (*test-pad-dots-helper* (- n 1))}
})

(fun {*test-pad-dots* str width} {
  do
    (printf "%s" str)
    (*test-pad-dots-helper* (- width (len str)))
})

(fun {*test-run-one* test} {
  do
    ; Debug: print raw test structure
    (printf "[DEBUG] Running test: ")
    (print test)

    ; Extract from the Q-expression
    ; head returns {name} so we eval it to get name
    ; tail returns {body} so head tail returns body which we keep as-is
    (= {test-name} (eval (head test)))
    (printf "[DEBUG] Test name extracted: %s\n" test-name)

    (= {test-body} (eval (head (tail test))))
    (printf "[DEBUG] Test body extracted: ")
    (print test-body)

    ; Time the test
    (= {start-time} (time-us {}))
    (printf "[DEBUG] About to eval test body...\n")
    (= {result} (eval test-body))
    (printf "[DEBUG] Test body result: ")
    (print result)
    (= {end-time} (time-us {}))
    (= {elapsed} (- end-time start-time))

    ; Check if result is an error
    (= {is-error} (error? result))
    (if is-error
      {printf "[DEBUG] Result is an ERROR!\n"}
      {true})

    ; Check if result is truthy (not error, not 0)
    (= {passed} (if (== result true) {1} {0}))
    (printf "[DEBUG] Passed = %ld\n" passed)

    ; Print result with emoji first, then name + dots (aligned with C tests)
    ; C tests use 100 char width: emoji(3) + name + dots = 97 total before "  PASS"
    (if (== passed 1)
      {do (printf "âœ… ") (*test-pad-dots* test-name 97) (printf "  PASS : in %ld(Âµs)\n" elapsed)}
      {do (printf "âŒ ") (*test-pad-dots* test-name 97) (printf "  FAIL : in %ld(Âµs)\n" elapsed)})

    (if (== passed 1)
      {(def {*test-passed*} (+ *test-passed* 1))}
      {(def {*test-failed*} (+ *test-failed* 1))})

    ; Return true to indicate test ran (even if it failed)
    true
})

(fun {test/run & args} {
  do
    (def {*test-passed*} 0)
    (def {*test-failed*} 0)
    (= {total} (len *test-registry*))

    ; Get suite name from args or from global variable
    (= {suite-name} *test-suite-name*)

    ; Check if we have any tests to run
    (if (== total 0)
      {do
        (printf "âŒ No tests registered!\n")
        (shutdown 1)}
      {true}
    )

    (printf "ğŸ§ª [%ld/%ld] %s\n" total total suite-name)

    ; Run tests and collect results
    (= {run-results} (map *test-run-one* *test-registry*))
    (= {tests-executed} (len run-results))

    ; Check if all tests executed
    (if (!= tests-executed total)
      {do
        (printf "\nâŒ ERROR: Only %ld/%ld tests executed!\n" tests-executed total)
        (shutdown 1)}
      {true})

    ; Print summary
    (printf "\nğŸ Test Results: ")
    (if (== *test-failed* 0)
      {printf "âœ¨ All %ld tests passed! âœ¨\n" *test-passed*}
      {printf "âš ï¸  %ld passed, %ld failed\n" *test-passed* *test-failed*})

    ; Exit with appropriate code
    (if (== *test-failed* 0)
      {(shutdown 0)}
      {(shutdown 1)})
})

(print "Test module loaded")
