; Simple test framework for Valkyria
; Supports both sync and async tests with timeout enforcement

; Default timeouts (milliseconds)
(def {*test-default-timeout-ms*} 5000)       ; 5 seconds per test
(def {*test-default-suite-timeout-ms*} 60000) ; 60 seconds for entire suite



(fun {test/context-new} {
  {:passed 0 :failed 0 :skipped 0 :timed-out 0
   :suite-name "Valkyria Test Suite" 
   :skip-suite 0 :skip-reason "" 
   :debug 0 :expected-exit 0
   :timeout-ms *test-default-timeout-ms*
   :suite-timeout-ms *test-default-suite-timeout-ms*}
})

(fun {test/debug ctx enabled} {
  (plist/set ctx :debug enabled)
})

(fun {test/suite ctx name} {
  (plist/set ctx :suite-name name)
})

(fun {test/skip ctx reason} {
  (= {ctx} (plist/set ctx :skip-suite 1))
  (plist/set ctx :skip-reason reason)
})

(fun {test/expect-exit ctx code} {
  (plist/set ctx :expected-exit code)
})

(fun {test/timeout ctx ms} {
  (plist/set ctx :timeout-ms ms)
})

(fun {test/suite-timeout ctx ms} {
  (plist/set ctx :suite-timeout-ms ms)
})

(fun {test name body} {
  (list name body)
})

(fun {test/add tests name body} {
  (join tests (list (test name body)))
})

(fun {test/assert cond msg} {
  if cond
    {true}
    {error msg}
})

(fun {test/assert-eq expected actual msg} {
  (test/assert (== expected actual) msg)
})

; Tail-recursive helper to print n dots
(fun {*test-pad-dots-helper* n} {
  if (<= n 0)
    {true}
    {do (printf ".") (*test-pad-dots-helper* (- n 1))}
})

(fun {*test-pad-dots* str width} {
  do
    (printf "%s" str)
    (*test-pad-dots-helper* (- width (len str)))
})

; Suite timeout callback - called if suite takes too long
(fun {*test-suite-timeout-cb* suite-name} {
  do
    (printf "\n\n‚è∞ SUITE TIMEOUT: %s exceeded time limit\n" suite-name)
    (shutdown 1)
})

; Run a single sync test with timeout (requires aio)
(fun {*test-run-one-with-timeout* aio ctx test} {
  do
    (= {test-name} (eval (head test)))
    (= {test-body} (head (tail test)))
    (= {skip-suite} (plist/get ctx :skip-suite))
    (= {debug} (plist/get ctx :debug))
    (= {timeout-ms} (plist/get ctx :timeout-ms))

    (if (== skip-suite 1)
      {do
        (printf "‚è≠Ô∏è  ") (*test-pad-dots* test-name 97) (printf "  SKIP\n")
        (plist/set ctx :skipped (+ (plist/get ctx :skipped) 1))}
      {do
        (if (== debug 1)
          {do
            (printf "[DEBUG] Running test: ")
            (print test)
            (printf "[DEBUG] Test name: %s\n" test-name)
            (printf "[DEBUG] Test body: ")
            (print test-body)}
          {true})

        ; Set up per-test timeout
        (= {timer-handle} (aio/schedule aio timeout-ms (\ {} {
          (printf "\n‚è∞ TEST TIMEOUT: %s\n" test-name)
        })))

        (= {start-time} (time-us {}))
        (= {result} (eval test-body))
        (= {end-time} (time-us {}))
        (= {elapsed} (- end-time start-time))

        ; Cancel timeout timer - returns :true if cancelled, :false if already completed
        (= {cancelled} (aio/cancel timer-handle))

        ; Check if we timed out (cancel failed means timer already fired)
        (if (== cancelled :false)
          {do
            (printf "‚è∞ ") (*test-pad-dots* test-name 97) (printf "  TIMEOUT : after %ldms\n" timeout-ms)
            (plist/set ctx :timed-out (+ (plist/get ctx :timed-out) 1))}
          {do
            (if (== debug 1)
              {do
                (printf "[DEBUG] Result: ")
                (print result)
                (if (error? result)
                  {printf "[DEBUG] Result is an ERROR!\n"}
                  {true})}
              {true})

            (= {passed} (if (== result true) {1} {0}))

            (if (== passed 1)
              {do (printf "‚úÖ ") (*test-pad-dots* test-name 97) (printf "  PASS : in %ld(¬µs)\n" elapsed)}
              {do (printf "‚ùå ") (*test-pad-dots* test-name 97) (printf "  FAIL : in %ld(¬µs)\n" elapsed)})

            (if (== passed 1)
              {(plist/set ctx :passed (+ (plist/get ctx :passed) 1))}
              {(plist/set ctx :failed (+ (plist/get ctx :failed) 1))})})})
})

; Run a single sync test without timeout (no aio)
(fun {*test-run-one-ctx* ctx test} {
  do
    (= {test-name} (eval (head test)))
    (= {test-body} (head (tail test)))
    (= {skip-suite} (plist/get ctx :skip-suite))
    (= {debug} (plist/get ctx :debug))

    (if (== skip-suite 1)
      {do
        (printf "‚è≠Ô∏è  ") (*test-pad-dots* test-name 97) (printf "  SKIP\n")
        (plist/set ctx :skipped (+ (plist/get ctx :skipped) 1))}
      {do
        (if (== debug 1)
          {do
            (printf "[DEBUG] Running test: ")
            (print test)
            (printf "[DEBUG] Test name: %s\n" test-name)
            (printf "[DEBUG] Test body: ")
            (print test-body)}
          {true})

        (= {start-time} (time-us {}))
        (= {result} (eval test-body))
        (= {end-time} (time-us {}))
        (= {elapsed} (- end-time start-time))

        (if (== debug 1)
          {do
            (printf "[DEBUG] Result: ")
            (print result)
            (if (error? result)
              {printf "[DEBUG] Result is an ERROR!\n"}
              {true})}
          {true})

        (= {passed} (if (== result true) {1} {0}))

        (if (== passed 1)
          {do (printf "‚úÖ ") (*test-pad-dots* test-name 97) (printf "  PASS : in %ld(¬µs)\n" elapsed)}
          {do (printf "‚ùå ") (*test-pad-dots* test-name 97) (printf "  FAIL : in %ld(¬µs)\n" elapsed)})

        (if (== passed 1)
          {(plist/set ctx :passed (+ (plist/get ctx :passed) 1))}
          {(plist/set ctx :failed (+ (plist/get ctx :failed) 1))})})
})

(fun {*is-test-list* arg} {
  (if (not (list? arg))
    {false}
    {(if (== (len arg) 0)
      {true}
      {(if (list? (head arg))
        {(== (len (head arg)) 2)}
        {false})})})
})

(fun {*test-is-keyword* val} {
  (= {s} (str val))
  (= {parts} (str/split s ":"))
  (if (< (len parts) 2)
    {false}
    {(== (head parts) "")})
})

(fun {*test-is-config* arg} {
  (if (not (list? arg))
    {false}
    {(if (== (len arg) 0)
      {false}
      {(*test-is-keyword* (head arg))})}
  )
})

(fun {*test-parse-args* args} {
  (= {tests} {})
  (= {config} {})
  (if (== (len args) 0)
    {(list tests config)}
    {do
      (= {first} (head args))
      (if (*is-test-list* first)
        {do
          (= {tests} first)
          (if (> (len args) 1)
            {(= {config} (head (tail args)))}
            {true})}
        {(if (*test-is-config* first)
          {(= {config} first)}
          {true})})
      (list tests config)})
})

(fun {*test-ctx-from-config* config} {
  (= {ctx} (test/context-new))
  (if (plist/has? config :suite-name)
    {(= {ctx} (plist/set ctx :suite-name (plist/get config :suite-name)))}
    {true})
  (if (plist/has? config :skip-suite)
    {(= {ctx} (plist/set ctx :skip-suite (plist/get config :skip-suite)))}
    {true})
  (if (plist/has? config :skip-reason)
    {(= {ctx} (plist/set ctx :skip-reason (plist/get config :skip-reason)))}
    {true})
  (if (plist/has? config :debug)
    {(= {ctx} (plist/set ctx :debug (plist/get config :debug)))}
    {true})
  (if (plist/has? config :expected-exit)
    {(= {ctx} (plist/set ctx :expected-exit (plist/get config :expected-exit)))}
    {true})
  (if (plist/has? config :timeout-ms)
    {(= {ctx} (plist/set ctx :timeout-ms (plist/get config :timeout-ms)))}
    {true})
  (if (plist/has? config :suite-timeout-ms)
    {(= {ctx} (plist/set ctx :suite-timeout-ms (plist/get config :suite-timeout-ms)))}
    {true})
  ctx
})

; Print final results and exit
(fun {*test-print-results-and-exit* ctx} {
  do
    (= {passed} (plist/get ctx :passed))
    (= {failed} (plist/get ctx :failed))
    (= {skipped} (plist/get ctx :skipped))
    (= {timed-out} (plist/get ctx :timed-out))
    (= {expected-exit} (plist/get ctx :expected-exit))

    (printf "\nüèÅ Test Results: ")
    (if (> timed-out 0)
      {printf "‚è∞ %ld timed out, " timed-out}
      {true})
    (if (> skipped 0)
      {printf "‚è≠Ô∏è  %ld skipped, " skipped}
      {true})
    (if (== (+ failed timed-out) 0)
      {printf "‚ú® All %ld tests passed! ‚ú®\n" passed}
      {printf "‚ö†Ô∏è  %ld passed, %ld failed\n" passed (+ failed timed-out)})

    (= {actual-exit} (if (== (+ failed timed-out) 0) {0} {1}))

    (if (== actual-exit expected-exit)
      {(shutdown 0)}
      {(shutdown actual-exit)})
})

; Main test runner - sync tests without aio (no per-test timeout, but has suite timeout awareness)
(fun {test/run & args} {
  do
    (= {parsed} (*test-parse-args* args))
    (= {tests} (head parsed))
    (= {config} (head (tail parsed)))
    (= {total} (len tests))

    (= {ctx} (*test-ctx-from-config* config))
    (= {expected-exit} (plist/get ctx :expected-exit))

    (if (== total 0)
      {do
        (printf "‚ùå No tests registered!\n")
        (if (== expected-exit 1)
          {(shutdown 0)}
          {(shutdown 1)})}
      {true})

    (= {suite-name} (plist/get ctx :suite-name))
    (= {skip-suite} (plist/get ctx :skip-suite))
    (= {skip-reason} (plist/get ctx :skip-reason))

    (if (== skip-suite 1)
      {printf "üß™ [%ld/%ld] %s (SKIPPED: %s)\n" total total suite-name skip-reason}
      {printf "üß™ [%ld/%ld] %s\n" total total suite-name})

    (= {final-ctx} (foldl *test-run-one-ctx* ctx tests))

    (*test-print-results-and-exit* final-ctx)
})

; Sync test runner WITH timeout support (requires aio system)
; Usage: (test/run-with-timeout aio tests {:suite-name "My Suite" :timeout-ms 5000})
(fun {test/run-with-timeout aio & args} {
  do
    (= {parsed} (*test-parse-args* args))
    (= {tests} (head parsed))
    (= {config} (head (tail parsed)))
    (= {total} (len tests))

    (= {ctx} (*test-ctx-from-config* config))
    (= {expected-exit} (plist/get ctx :expected-exit))
    (= {suite-timeout-ms} (plist/get ctx :suite-timeout-ms))
    (= {timeout-ms} (plist/get ctx :timeout-ms))

    (if (== total 0)
      {do
        (printf "‚ùå No tests registered!\n")
        (if (== expected-exit 1)
          {(shutdown 0)}
          {(shutdown 1)})}
      {true})

    (= {suite-name} (plist/get ctx :suite-name))
    (= {skip-suite} (plist/get ctx :skip-suite))
    (= {skip-reason} (plist/get ctx :skip-reason))

    (if (== skip-suite 1)
      {printf "üß™ [%ld/%ld] %s (SKIPPED: %s)\n" total total suite-name skip-reason}
      {printf "üß™ [%ld/%ld] %s (timeout: %ldms/test, %ldms/suite)\n" total total suite-name timeout-ms suite-timeout-ms})

    ; Run all tests with individual timeouts, racing against suite timeout
    (= {test-handle} (aio/pure (foldl (\ {ctx test} {(*test-run-one-with-timeout* aio ctx test)}) ctx tests)))
    (= {timeout-handle} (aio/then (aio/sleep aio suite-timeout-ms) (\ {_} {:suite-timeout})))
    (= {race-result} (aio/race (list test-handle timeout-handle)))
    (= {final-ctx} (if (== race-result :suite-timeout)
                     {do
                       (*test-suite-timeout-cb* suite-name)
                       ctx}
                     {race-result}))

    ; Stop aio and print results
    (aio/stop aio)
    (*test-print-results-and-exit* final-ctx)
})

; ============================================================================
; Async Test Support
; ============================================================================
; For tests that require the event loop (HTTP, timers, etc.)
; Usage:
;   (= {tests} (-> {} (test/async-add "test name" (\ {done} { ... (done true) }))))
;   (test/run-async aio tests {:timeout-ms 5000 :suite-timeout-ms 30000})
;   (aio/run aio)



(fun {test-async name body} {
  (list name body)
})

(fun {test/async-add tests name body} {
  (join tests (list (test-async name body)))
})





(fun {*test-run-async-one* aio timeout-ms test} {
  do
    (= {test-name} (eval (head test)))
    (= {test-body} (eval (head (tail test))))
    (= {start-time} (time-us {}))
    
    ; Test body is (\ {} {returns-handle-completing-with-pass/fail-result})
    ; Call the test body to get the handle
    (= {test-handle} (test-body))
    
    ; Validate that test body returned a handle - fail fast if not
    (if (not (handle? test-handle))
      {(do
        (printf "\n\nFATAL: test-async body must return a handle!\n")
        (printf "  Test: %s\n" test-name)
        (printf "  Got:  %s\n\n" (str test-handle))
        (shutdown 1))}
      {true})
    
    ; Transform the test result into standardized format with timing
    (= {result-handle} (aio/then test-handle (\ {result} {
      (= {end-time} (time-us {}))
      (= {elapsed} (- end-time start-time))
      (= {passed} (if (== result true) {1} 
                    {(if (== result :pass) {1}
                      {(if (plist/has? result :status) 
                        {(== (plist/get result :status) :pass)}
                        {0})})}))
      (if (== passed 1)
        (list :status :pass :name test-name :elapsed elapsed)
        (list :status :fail :name test-name :elapsed elapsed))
    })))
    
    ; Apply timeout using aio/within and handle timeout error
    (= {within-h} (aio/within result-handle timeout-ms))
    (= {error-fn} (\ {err} {
                 (= {end-time} (time-us {}))
                 (= {elapsed} (- end-time start-time))
                 (list :status :timeout :name test-name :elapsed elapsed)
               }))
    (= {catch-h} (aio/catch within-h error-fn))
    catch-h
})



(fun {*test-async-parse-args* args} {
  (= {tests} {})
  (= {config} {})
  (if (== (len args) 0)
    {(list tests config)}
    {do
      (= {first} (head args))
      (if (*is-test-list* first)
        {do
          (= {tests} first)
          (if (> (len args) 1)
            {(= {config} (head (tail args)))}
            {true})}
        {(if (*test-is-config* first)
          {(= {config} first)}
          {true})})
      (list tests config)})
})

(fun {*test-async-ctx-from-config* config} {
  (= {ctx} {:suite-name "Valkyria Test Suite" :expected-exit 0 
            :timeout-ms *test-default-timeout-ms* 
            :suite-timeout-ms *test-default-suite-timeout-ms*})
  (if (plist/has? config :suite-name)
    {(= {ctx} (plist/set ctx :suite-name (plist/get config :suite-name)))}
    {true})
  (if (plist/has? config :expected-exit)
    {(= {ctx} (plist/set ctx :expected-exit (plist/get config :expected-exit)))}
    {true})
  (if (plist/has? config :timeout-ms)
    {(= {ctx} (plist/set ctx :timeout-ms (plist/get config :timeout-ms)))}
    {true})
  (if (plist/has? config :suite-timeout-ms)
    {(= {ctx} (plist/set ctx :suite-timeout-ms (plist/get config :suite-timeout-ms)))}
    {true})
  ctx
})

(fun {test/run-async aio & args} {
  do
    (= {parsed} (*test-async-parse-args* args))
    (= {tests} (head parsed))
    (= {config} (head (tail parsed)))
    (= {total} (len tests))

    (= {ctx} (*test-async-ctx-from-config* config))
    (= {suite-name} (plist/get ctx :suite-name))
    (= {expected-exit} (plist/get ctx :expected-exit))
    (= {timeout-ms} (plist/get ctx :timeout-ms))
    (= {suite-timeout-ms} (plist/get ctx :suite-timeout-ms))
    
    (if (== total 0)
      {do
        (printf "‚ùå No async tests registered!\n")
        (if (== expected-exit 1)
          {(shutdown 0)}
          {(shutdown 1)})}
      {true})
    
    (printf "üß™ [%ld/%ld] %s (async, timeout: %ldms/test, %ldms/suite)\n" total total suite-name timeout-ms suite-timeout-ms)
    
    ; Create handles for all tests
    (= {test-handles} (map (\ {test} {(*test-run-async-one* aio timeout-ms test)}) tests))
    
    ; Use aio/all to collect all test results, with suite timeout
    (= {all-tests-handle} (aio/all test-handles))
    (= {suite-timeout-handle} (aio/then (aio/sleep aio suite-timeout-ms) (\ {_} {:suite-timeout})))
    (= {race-result} (aio/race (list all-tests-handle suite-timeout-handle)))
    
    ; Process results
    (= {results-handle} (aio/then race-result (\ {result} {
      (if (== result :suite-timeout)
        {do
          (printf "\n‚è∞ SUITE TIMEOUT: Suite exceeded %ldms\n" suite-timeout-ms)
          (aio/stop aio)
          (shutdown 1)}
        {do
          ; Print individual test results and aggregate counts using foldl
          (= {counts} (foldl (\ {acc test-result} {
            (= {status} (plist/get test-result :status))
            (= {name} (plist/get test-result :name))
            (= {elapsed} (plist/get test-result :elapsed))
            (= {passed} (plist/get acc :passed))
            (= {failed} (plist/get acc :failed))
            (= {timed-out} (plist/get acc :timed-out))
            (select
              {(== status :pass) (do 
                (printf "‚úÖ ") (*test-pad-dots* name 97) (printf "  PASS : in %ld(¬µs)\n" elapsed)
                (plist/set acc :passed (+ passed 1)))}
              {(== status :fail) (do 
                (printf "‚ùå ") (*test-pad-dots* name 97) (printf "  FAIL : in %ld(¬µs)\n" elapsed)
                (plist/set acc :failed (+ failed 1)))}
              {(== status :timeout) (do 
                (printf "‚è∞ ") (*test-pad-dots* name 97) (printf "  TIMEOUT : after %ldms\n" timeout-ms)
                (plist/set acc :timed-out (+ timed-out 1)))}
              {true (do 
                (printf "‚ùì ") (*test-pad-dots* name 97) (printf "  UNKNOWN : %s\n" (str status))
                (plist/set acc :failed (+ failed 1)))})
          }) {:passed 0 :failed 0 :timed-out 0} result))
          
          (= {passed} (plist/get counts :passed))
          (= {failed} (plist/get counts :failed))
          (= {timed-out} (plist/get counts :timed-out))
          
          ; Print final results
          (printf "\nüèÅ Test Results: ")
          (if (> timed-out 0)
            {printf "‚è∞ %ld timed out, " timed-out}
            {true})
          (if (== (+ failed timed-out) 0)
            {printf "‚ú® All %ld tests passed! ‚ú®\n" passed}
            {printf "‚ö†Ô∏è  %ld passed, %ld failed\n" passed (+ failed timed-out)})
          
          (aio/stop aio)
          (= {actual-exit} (if (== (+ failed timed-out) 0) {0} {1}))
          (if (== actual-exit expected-exit)
            {(shutdown 0)}
            {(shutdown actual-exit)})})
    })))
    
    (= {on-loop} (aio/on-loop-thread? aio))
    (if on-loop
      {true}
      {(aio/run aio)})
})



; Test module loaded
