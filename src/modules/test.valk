; Simple test framework for Valkyria

(def {*test-registry*} {})
(def {*test-suite-name*} "Valkyria Test Suite")
(def {*test-skip-suite*} 0)      ; Set to 1 to skip all tests in suite
(def {*test-skip-reason*} "")    ; Reason for skipping
(def {*test-debug*} 0)           ; Set to 1 to enable debug output
(def {*test-expected-exit*} 0)   ; Expected exit code (0 = pass, 1 = fail expected)

(fun {test/context-new} {
  {:passed 0 :failed 0 :skipped 0 :suite-name "Valkyria Test Suite" :skip-suite 0 :skip-reason "" :debug 0 :expected-exit 0}
})

(fun {test/debug enabled} {
  (def {*test-debug*} enabled)
})

(fun {test/suite name} {
  (def {*test-suite-name*} name)
})

; Skip all tests in this suite with a reason
(fun {test/skip reason} {
  (def {*test-skip-suite*} 1)
  (def {*test-skip-reason*} reason)
})

; Expect the test suite to exit with a specific code
; Use this when testing error paths that should cause test failures
(fun {test/expect-exit code} {
  (def {*test-expected-exit*} code)
})

(fun {test name body} {
  (list name body)
})

(fun {test/define name body} {
  (def {*test-registry*} (join *test-registry* (list (test name body))))
})

(fun {test/assert cond msg} {
  if cond
    {true}
    {error msg}
})

(fun {test/assert-eq expected actual msg} {
  (test/assert (== expected actual) msg)
})

; Tail-recursive helper to print n dots
(fun {*test-pad-dots-helper* n} {
  if (<= n 0)
    {true}
    {do (printf ".") (*test-pad-dots-helper* (- n 1))}
})

(fun {*test-pad-dots* str width} {
  do
    (printf "%s" str)
    (*test-pad-dots-helper* (- width (len str)))
})

(fun {*test-run-one-ctx* ctx test} {
  do
    (= {test-name} (eval (head test)))
    (= {test-body} (head (tail test)))
    (= {skip-suite} (plist/get ctx :skip-suite))
    (= {debug} (plist/get ctx :debug))

    (if (== skip-suite 1)
      {do
        (printf "â­ï¸  ") (*test-pad-dots* test-name 97) (printf "  SKIP\n")
        (plist/set ctx :skipped (+ (plist/get ctx :skipped) 1))}
      {do
        (if (== debug 1)
          {do
            (printf "[DEBUG] Running test: ")
            (print test)
            (printf "[DEBUG] Test name: %s\n" test-name)
            (printf "[DEBUG] Test body: ")
            (print test-body)}
          {true})

        (= {start-time} (time-us {}))
        (= {result} (eval test-body))
        (= {end-time} (time-us {}))
        (= {elapsed} (- end-time start-time))

        (if (== debug 1)
          {do
            (printf "[DEBUG] Result: ")
            (print result)
            (if (error? result)
              {printf "[DEBUG] Result is an ERROR!\n"}
              {true})}
          {true})

        (= {passed} (if (== result true) {1} {0}))

        (if (== passed 1)
          {do (printf "âœ… ") (*test-pad-dots* test-name 97) (printf "  PASS : in %ld(Âµs)\n" elapsed)}
          {do (printf "âŒ ") (*test-pad-dots* test-name 97) (printf "  FAIL : in %ld(Âµs)\n" elapsed)})

        (if (== passed 1)
          {(plist/set ctx :passed (+ (plist/get ctx :passed) 1))}
          {(plist/set ctx :failed (+ (plist/get ctx :failed) 1))})})
})

(fun {*is-test-list* arg} {
  (if (not (list? arg))
    {false}
    {(if (== (len arg) 0)
      {false}
      {(if (list? (head arg))
        {(== (len (head arg)) 2)}
        {false})})})
})

(fun {test/run & args} {
  do
    (= {tests} (if (> (len args) 0)
      {(if (*is-test-list* (head args))
        {(head args)}
        {*test-registry*})}
      {*test-registry*}))
    (= {total} (len tests))

    (if (== total 0)
      {do
        (printf "âŒ No tests registered!\n")
        (if (== *test-expected-exit* 1)
          {(shutdown 0)}
          {(shutdown 1)})}
      {true})

    (= {ctx} (test/context-new))
    (= {ctx} (plist/set ctx :suite-name *test-suite-name*))
    (= {ctx} (plist/set ctx :skip-suite *test-skip-suite*))
    (= {ctx} (plist/set ctx :skip-reason *test-skip-reason*))
    (= {ctx} (plist/set ctx :debug *test-debug*))
    (= {ctx} (plist/set ctx :expected-exit *test-expected-exit*))

    (= {suite-name} (plist/get ctx :suite-name))
    (= {skip-suite} (plist/get ctx :skip-suite))
    (= {skip-reason} (plist/get ctx :skip-reason))

    (if (== skip-suite 1)
      {printf "ğŸ§ª [%ld/%ld] %s (SKIPPED: %s)\n" total total suite-name skip-reason}
      {printf "ğŸ§ª [%ld/%ld] %s\n" total total suite-name})

    (= {final-ctx} (foldl *test-run-one-ctx* ctx tests))

    (= {passed} (plist/get final-ctx :passed))
    (= {failed} (plist/get final-ctx :failed))
    (= {skipped} (plist/get final-ctx :skipped))
    (= {expected-exit} (plist/get final-ctx :expected-exit))

    (printf "\nğŸ Test Results: ")
    (if (> skipped 0)
      {printf "â­ï¸  %ld skipped\n" skipped}
      {(if (== failed 0)
        {printf "âœ¨ All %ld tests passed! âœ¨\n" passed}
        {printf "âš ï¸  %ld passed, %ld failed\n" passed failed})})

    (= {actual-exit} (if (== failed 0) {0} {1}))

    (if (== actual-exit expected-exit)
      {(shutdown 0)}
      {(shutdown actual-exit)})
})

; ============================================================================
; Async Test Support
; ============================================================================
; For tests that require the event loop (HTTP, timers, etc.)
; Usage:
;   (test/async "test name" (\ {done} { ... (done true) }))
;   (test/run-async aio)
;   (aio/run aio)

(def {*test-async-registry*} {})
(def {*test-async-pending-atom*} (atom 0))
(def {*test-async-passed-atom*} (atom 0))
(def {*test-async-failed-atom*} (atom 0))

(fun {test-async name body} {
  (list name body)
})

(fun {test/async name body} {
  (def {*test-async-registry*} (join *test-async-registry* (list (test-async name body))))
})

(fun {*test-async-done-callback* test-name start-time passed} {
  do
    (= {end-time} (time-us {}))
    (= {elapsed} (- end-time start-time))
    
    (if passed
      {do
        (printf "âœ… ") (*test-pad-dots* test-name 97) (printf "  PASS : in %ld(Âµs)\n" elapsed)
        (atom/add! *test-async-passed-atom* 1)}
      {do
        (printf "âŒ ") (*test-pad-dots* test-name 97) (printf "  FAIL : in %ld(Âµs)\n" elapsed)
        (atom/add! *test-async-failed-atom* 1)})
    
    (atom/sub! *test-async-pending-atom* 1)
    true
})

(fun {*test-start-async-one* aio test} {
  do
    (= {test-name} (eval (head test)))
    (= {test-body} (eval (head (tail test))))
    (= {start-time} (time-us {}))
    
    (= {done-fn} (\ {passed} {
      (*test-async-done-callback* test-name start-time passed)
    }))
    
    (atom/add! *test-async-pending-atom* 1)
    
    (aio/schedule aio 0 (\ {} {
      (test-body done-fn)
    }))
})

(fun {test/run-async aio & args} {
  do
    (atom/set! *test-async-passed-atom* 0)
    (atom/set! *test-async-failed-atom* 0)
    (atom/set! *test-async-pending-atom* 0)
    (= {tests} (if (> (len args) 0)
      {(if (list? (head args))
        {(head args)}
        {*test-async-registry*})}
      {*test-async-registry*}))
    (= {total} (len tests))
    (= {suite-name} *test-suite-name*)
    
    (if (== total 0)
      {do
        (printf "âŒ No async tests registered!\n")
        (if (== *test-expected-exit* 1)
          {(shutdown 0)}
          {(shutdown 1)})}
      {true})
    
    (printf "ğŸ§ª [%ld/%ld] %s (async)\n" total total suite-name)
    
    (map (\ {test} {(*test-start-async-one* aio test)}) tests)
    
    (aio/schedule aio 30000 (\ {} {
      (if (> (atom/get *test-async-pending-atom*) 0)
        {do
          (printf "\nâŒ TIMEOUT: %ld tests still pending\n" (atom/get *test-async-pending-atom*))
          (aio/stop aio)
          (shutdown 1)}
        {true})
    }))
    
    (aio/schedule aio 100 (\ {} {
      (*test-async-check-complete* aio)
    }))
    
    (if (aio/on-loop-thread? aio)
      {true}
      {(aio/run aio)})
})

(fun {*test-async-check-complete* aio} {
  (if (== (atom/get *test-async-pending-atom*) 0)
    {do
      (= {passed} (atom/get *test-async-passed-atom*))
      (= {failed} (atom/get *test-async-failed-atom*))
      (printf "\nğŸ Test Results: ")
      (if (== failed 0)
        {printf "âœ¨ All %ld tests passed! âœ¨\n" passed}
        {printf "âš ï¸  %ld passed, %ld failed\n" passed failed})
      (aio/stop aio)
      (= {actual-exit} (if (== failed 0) {0} {1}))
      (if (== actual-exit *test-expected-exit*)
        {(shutdown 0)}
        {(shutdown actual-exit)})}
    {(aio/schedule aio 100 (\ {} {(*test-async-check-complete* aio)}))})
})

; Test module loaded - no debug output
