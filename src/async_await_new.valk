; New async/await implementation using shift/reset continuations
; This completely replaces futures/promises with continuations

; async: Create async context
(def {async} (macro {body} {
  (async-reset body)
}))

; await-new: Suspend and wait for async operation
; This captures the continuation and passes it to the async operation
(def {await-new} (macro {async-op} {
  (async-shift {k}
    ; The async operation should take a continuation as last arg
    ; When it completes, it calls the continuation with the result
    (let {op async-op}
      ; Add continuation to the operation
      (if (== (type op) "list")
        ; If it's a function call, append k as last arg
        (eval (join op (list k)))
        ; Otherwise just call with k
        (op k))))
}))

; Helper to make async operations easier to write
(def {make-async} (fn {sync-fn} {
  (fn {args} {
    ; Extract continuation from args
    (def {k} (last args))
    (def {sync-args} (init args))
    ; Call sync function and then continuation
    (def {result} (eval (cons sync-fn sync-args)))
    (k result)
  })
}))

; Example async operations using the new model
(def {connect-async} (fn {host port k} {
  ; This would integrate with libuv
  ; For now, simulate async with immediate callback
  (print "Connecting to" host ":" port "...")
  (def {client} (list 'client host port))
  (k client)  ; Resume continuation with client
}))

(def {send-async} (fn {client request k} {
  ; Simulate sending request
  (print "Sending request...")
  (def {response} (list 'response "200 OK" "Hello from async!"))
  (k response)  ; Resume continuation with response
}))

; Example usage:
; (async {
;   (def {client} (await-new (connect-async "google.com" 443)))
;   (print "Connected:" client)
;   (def {response} (await-new (send-async client request)))
;   (print "Response:" response)
; })