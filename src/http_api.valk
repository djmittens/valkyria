; High-Level HTTP API for Valkyria
; Built on top of async monadic combinators and http2 primitives
;
; Architecture:
;   1. Request/Response abstraction layer
;   2. Client API with connection management
;   3. Route matching and handler system
;   4. Middleware composition
;   5. Error handling patterns

(load "src/async_monadic.valk")

; ============================================================================
; PART 1: Request/Response Helpers
; ============================================================================

; Create a GET request
(fun {http/get url} {
  (= {req} (http2/request "GET" "https" url "/"))
  (http2/request-add-header req ":method" "GET")
  (http2/request-add-header req "user-agent" "Valkyria/1.0")
  req
})

; Create a POST request with body
(fun {http/post url body} {
  (= {req} (http2/request "POST" "https" url "/"))
  (http2/request-add-header req ":method" "POST")
  (http2/request-add-header req "content-type" "application/json")
  (http2/request-add-header req "user-agent" "Valkyria/1.0")
  ; TODO: Add body support
  req
})

; Create a request with custom method
(fun {http/request method url} {
  (= {req} (http2/request method "https" url "/"))
  (http2/request-add-header req ":method" method)
  (http2/request-add-header req "user-agent" "Valkyria/1.0")
  req
})

; Add header to request (chainable)
(fun {http/with-header req name value} {
  (http2/request-add-header req name value)
  req
})

; Add multiple headers
(fun {http/with-headers req headers} {
  (= {add-header} (\ {r h} {
    (http/with-header r (head h) (head (tail h)))
  }))
  (foldl add-header req headers)
})

; Extract response status
(fun {http/response-status resp} {
  (http2/response-status resp)
})

; Extract response body as string
(fun {http/response-body resp} {
  (http2/response-body resp)
})

; Extract response headers
(fun {http/response-headers resp} {
  (http2/response-headers resp)
})

; Check if response is success (2xx)
(fun {http/response-ok? resp} {
  (= {status} (http/response-status resp))
  (if (>= status 200)
    {(< status 300)}
    {0})
})

; ============================================================================
; PART 2: Async HTTP Client API
; ============================================================================

; Low-level: Connect and send request (returns async operation)
(fun {http/fetch-async url request} {
  (\ {k} {
    ; First connect to server
    (http2/connect-async url (\ {client} {
      ; Then send request
      (http2/send-async client request (\ {response} {
        ; Return response via continuation
        (k response)
      }))
    }))
  })
})

; High-level: Fetch URL with GET request
(fun {http/fetch url} {
  (= {req} (http/get url))
  (http/fetch-async url req)
})

; Fetch with custom request
(fun {http/fetch-with-request url request} {
  (http/fetch-async url request)
})

; Fetch and extract body
(fun {http/fetch-text url} {
  (async/bind (http/fetch url) (\ {resp} {
    (async/pure (http/response-body resp))
  }))
})

; Fetch and check if successful
(fun {http/fetch-ok? url} {
  (async/bind (http/fetch url) (\ {resp} {
    (async/pure (http/response-ok? resp))
  }))
})

; ============================================================================
; PART 3: Batch Operations
; ============================================================================

; Fetch multiple URLs in sequence
(fun {http/fetch-all urls} {
  (async/map-list http/fetch urls)
})

; Fetch multiple URLs and extract bodies
(fun {http/fetch-all-text urls} {
  (async/map-list http/fetch-text urls)
})

; Fetch with retry logic (simple version)
(fun {http/fetch-retry url max-retries} {
  (\ {k} {
    (= {try-fetch} (\ {retries} {
      (http/fetch url (\ {resp} {
        (if (http/response-ok? resp)
          {(k resp)}
          {(if (> retries 0)
            {(try-fetch (- retries 1))}
            {(k resp)})})
      }))
    }))
    (try-fetch max-retries)
  })
})

; ============================================================================
; PART 4: Request Pipeline & Middleware
; ============================================================================

; Middleware: function that transforms request → async request
; Type: Request → (Request → k) → k

; Add authentication header
(fun {http/with-auth token} {
  (\ {req} {
    (http/with-header req "authorization" token)
  })
})

; Add custom user agent
(fun {http/with-user-agent agent} {
  (\ {req} {
    (http/with-header req "user-agent" agent)
  })
})

; Log request before sending
(fun {http/with-logging req} {
  (print "HTTP Request:" req)
  req
})

; Apply middleware to request
(fun {http/apply-middleware req middleware} {
  (middleware req)
})

; Compose multiple middleware functions
(fun {http/compose-middleware middleware-list} {
  (\ {req} {
    (foldl (\ {r mw} {(mw r)}) req middleware-list)
  })
})

; ============================================================================
; PART 5: Response Pipeline
; ============================================================================

; Response middleware: function that transforms response → async response
; Type: Response → (Response → k) → k

; Log response
(fun {http/log-response resp} {
  (print "HTTP Response:" (http/response-status resp))
  resp
})

; Extract JSON body (placeholder - needs JSON parser)
(fun {http/parse-json-response resp} {
  ; TODO: Implement JSON parsing
  (http/response-body resp)
})

; Validate response status
(fun {http/validate-status expected-status} {
  (\ {resp} {
    (= {status} (http/response-status resp))
    (if (== status expected-status)
      {resp}
      {(error "Unexpected status:" status)})
  })
})

; ============================================================================
; PART 6: Route Matching (for server-side, future)
; ============================================================================

; Route: (method, path-pattern, handler)
; Handler: Request → (Response → k) → k

; Simple path matching (exact match for now)
(fun {http/route-matches? pattern path} {
  (== pattern path)
})

; Find matching route
(fun {http/find-route routes method path} {
  (= {matches} (\ {route} {
    (if (== (head route) method)
      {(http/route-matches? (head (tail route)) path)}
      {0})
  }))
  (head (filter matches routes))
})

; ============================================================================
; PART 7: Error Handling
; ============================================================================

; NOTE: Use async/try and async/recover from async_monadic.valk for error handling
; Example: (async/try risky-op) -> returns (list "ok" result) or (list "error" err)
; Example: (async/recover risky-op fallback-op) -> tries risky-op, falls back on error

; ============================================================================
; PART 8: Common Patterns
; ============================================================================

; Parallel requests (currently sequential due to implementation)
(fun {http/parallel async-ops} {
  (async/collect async-ops)
})

; Sequential requests with dependencies
(fun {http/sequential async-ops} {
  (async/sequence async-ops)
})

; Fan-out pattern: fetch related resources
(fun {http/fan-out url extractors} {
  (async/bind (http/fetch url) (\ {resp} {
    (= {urls} (map (\ {ext} {(ext resp)}) extractors))
    (http/fetch-all urls)
  }))
})

; Aggregate pattern: fetch and combine
(fun {http/aggregate urls combiner} {
  (async/bind (http/fetch-all urls) (\ {responses} {
    (async/pure (combiner responses))
  }))
})

; ============================================================================
; PART 9: Convenience Functions
; ============================================================================

; Simple synchronous-style fetch (using async/run)
(fun {http/fetch-sync url} {
  (async/run (http/fetch url))
})

; Fetch and print response
(fun {http/fetch-and-print url} {
  (= {resp} (http/fetch-sync url))
  (print "Status:" (http/response-status resp))
  (print "Body:" (http/response-body resp))
  resp
})

; Health check endpoint
(fun {http/health-check url} {
  (async/bind (http/fetch url) (\ {resp} {
    (async/pure (http/response-ok? resp))
  }))
})

; Batch health checks
(fun {http/health-check-all urls} {
  (async/map-list http/health-check urls)
})

; ============================================================================
; PART 10: Builder Pattern
; ============================================================================

; Request builder for fluent API
(fun {http/request-builder method url} {
  (list
    (list "method" method)
    (list "url" url)
    (list "headers" ())
  )
})

; Add header to builder
(fun {http/builder-add-header builder name value} {
  ; TODO: Implement proper builder pattern
  builder
})

; Build final request from builder
(fun {http/builder-build builder} {
  ; TODO: Convert builder to actual request
  (http/request
    (head (tail (head builder)))
    (head (tail (head (tail builder)))))
})

; ============================================================================
; EXPORTS / PUBLIC API
; ============================================================================

; Core request creation
; - http/get, http/post, http/request
; - http/with-header, http/with-headers

; Fetching
; - http/fetch, http/fetch-text, http/fetch-ok?
; - http/fetch-all, http/fetch-all-text
; - http/fetch-sync, http/fetch-and-print

; Response handling
; - http/response-status, http/response-body, http/response-headers, http/response-ok?

; Middleware
; - http/with-auth, http/with-user-agent, http/with-logging
; - http/compose-middleware, http/apply-middleware

; Patterns
; - http/parallel, http/sequential, http/fan-out, http/aggregate
; - http/health-check, http/health-check-all

; Error handling (use async_monadic.valk)
; - async/try, async/recover

; HTTP API loaded
