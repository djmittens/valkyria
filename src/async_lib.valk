; Async/Await Library - Utilities for the new continuation-based system
; This provides higher-level async patterns on top of async-shift/async-reset

; === Core Async Macros ===

; async: Create an async context
(def {async} (\ {body} {
  (async-reset body)
}))

; await-async: Suspend and wait for async operation
; For now, this is just an identity - users must manually pass k
; e.g., (async-shift {k} {(fetch-user-async 42 k)})
; TODO: Make this actually work as a proper macro
(def {await-async} (\ {op k} {
  (op k)
}))

; === Async Combinators ===

; async-all: Run multiple async operations and collect all results
; Usage: (async-all (list op1 op2 op3))
(def {async-all} (\ {ops} {
  (if (== ops ())
    ()
    (async {
      (def {results} ())
      (map (\ {op} {
        (def {result} (await-async op))
        (= {results} (join results (list result)))
      }) ops)
      results
    }))
}))

; async-race: Return the first completed operation
; NOTE: Simplified - in real implementation would cancel others
(def {async-race} (\ {ops} {
  ; For now, just return first (simplified)
  (if (== ops ())
    (error "async-race: empty list")
    (async {
      (await-async (head ops))
    }))
}))

; async-map: Map an async function over a list sequentially
(def {async-map} (\ {async-fn items} {
  (async {
    (def {results} ())
    (def {process-item} (\ {item} {
      (def {result} (await-async (async-fn item)))
      (= {results} (join results (list result)))
    }))
    (map process-item items)
    results
  })
}))

; async-filter: Filter items using an async predicate
(def {async-filter} (\ {async-pred items} {
  (async {
    (def {results} ())
    (def {check-item} (\ {item} {
      (def {keep} (await-async (async-pred item)))
      (if keep
        (= {results} (join results (list item)))
        nil)
    }))
    (map check-item items)
    results
  })
}))

; async-reduce: Reduce with an async function
(def {async-reduce} (\ {async-fn init items} {
  (async {
    (def {acc} init)
    (def {process} (\ {item} {
      (= {acc} (await-async (async-fn acc item)))
    }))
    (map process items)
    acc
  })
}))

; === Async Flow Control ===

; async-series: Execute async operations in series
(def {async-series} (\ {ops} {
  (async {
    (def {results} ())
    (def {run-op} (\ {op} {
      (def {result} (await-async op))
      (= {results} (join results (list result)))
    }))
    (map run-op ops)
    results
  })
}))

; async-waterfall: Pass result of each operation to the next
(def {async-waterfall} (\ {ops} {
  (async {
    (def {result} nil)
    (def {run-next} (\ {op} {
      (if (== result nil)
        (= {result} (await-async op))
        (= {result} (await-async (op result))))
    }))
    (map run-next ops)
    result
  })
}))

; async-retry: Simplified retry (error detection not yet implemented)
(def {async-retry} (\ {op max-retries delay} {
  ; For now, just run once
  (async {
    (await-async op)
  })
}))

; === Async Utilities ===

; async-delay: Delay execution (mock - would use timer in real impl)
(def {async-delay} (\ {ms k} {
  (print "Delaying" ms "ms...")
  (k nil)
}))

; async-timeout: Add timeout to async operation
(def {async-timeout} (\ {op timeout-ms} {
  (async {
    ; Simplified - would race with actual timer
    (await-async op)
  })
}))

; === Error Handling ===

; async-try-catch: Try/catch for async operations (simplified)
(def {async-try-catch} (macro {try-body catch-sym catch-body} {
  (async {
    ; For now, just execute the try body
    (await-async try-body)
  })
}))

; async-finally: Ensure cleanup runs regardless of success/failure
(def {async-finally} (macro {body finally-body} {
  (async {
    (def {result} (await-async body))
    (eval finally-body)
    result
  })
}))

; === Parallel Execution Helpers ===

; async-parallel: Execute operations in parallel (simulated)
; In real implementation, would use work-stealing queue
(def {async-parallel} (\ {ops} {
  ; For now, sequential (would be parallel with real scheduler)
  (async-all ops)
}))

; async-parallel-limit: Execute with concurrency limit (simplified)
(def {async-parallel-limit} (\ {limit ops} {
  ; For now, just run all ops sequentially
  (async-all ops)
}))

(print "Async library loaded - Continuation-based async/await ready!")