{"t": "spec", "spec": "debug-dashboard-validation.md"}
{"t": "task", "id": "t-86eb", "spec": "debug-dashboard-validation.md", "name": "Fix TSAN async handle result/error race", "s": "d", "notes": "Root cause: handle->result and handle->error are plain pointers written by event loop thread (valk_async_handle_complete/fail at aio_async.c:259,292) and read by main thread (valk_async_handle_await_timeout at aio_async.c:492,494). Fix: Make result/error _Atomic pointers in valk_async_handle_t struct (aio.h:46-47) and use atomic_store/atomic_load with release/acquire semantics in writers/readers.", "accept": "make test-c-tsan passes without race warnings on async handle result field", "done_at": "a7c04fd"}
{"t": "task", "id": "t-goo1", "spec": "debug-dashboard-validation.md", "name": "Fix TSAN Chase-Lev deque race", "s": "d", "accept": "make test-c-tsan passes - no race warnings in aio_chase_lev.c", "done_at": "78956c4"}
{"t": "task", "id": "t-xy5b", "spec": "debug-dashboard-validation.md", "name": "Fix TSAN task queue struct races", "s": "d", "accept": "make test-c-tsan passes - no race warnings in aio_task_queue.c or aio_task.c", "done_at": "1f2663e"}
{"t": "task", "id": "t-cogi", "spec": "debug-dashboard-validation.md", "name": "Fix TSAN region allocator race in system_region", "s": "d", "notes": "Root cause: valk_region_alloc() at gc.c:1228-1229 updates stats.bytes_allocated and stats.alloc_count non-atomically. The system_region in valk_aio_system_t is accessed from both main thread (valk_aio_interval, valk_aio_schedule, valk_async_handle_new) and event loop thread (valk_async_propagate_results via VALK_WITH_ALLOC at aio_combinators.c:838,899). Fix options: (1) Make stats fields _Atomic, (2) Use atomics only for stats updates in valk_region_alloc, (3) Remove stats tracking for cross-thread regions.", "accept": "make test-c-tsan passes - no race warnings in gc.c region allocator", "done_at": "6b45195"}
{"t": "task", "id": "t-wkx6", "spec": "debug-dashboard-validation.md", "name": "Add STW coordination for scratch evacuation checkpoint", "s": "p", "notes": "Root cause: valk_checkpoint() (gc.c:2226) runs on main thread between expressions and mutates pointers in-place at lines 1911, 1936, 1951, 1964, 2084-2085, 2121, 2137, 2155, 2164. Event loop thread reads these via timer callbacks (aio_combinators.c:32-40). Fix approach: (1) Add new GC phase VALK_GC_PHASE_CHECKPOINT_REQUESTED, (2) Before valk_checkpoint() mutates pointers, set phase and wait for event loop to pause at safe point, (3) After checkpoint completes, resume event loop. Alternative: use atomic stores for pointer updates and acquire loads in readers, but this is more invasive.", "accept": "make test-valk-tsan passes with no data race reports on gc.c:1911-2166. Verify with stress test that runs interval timers while main thread evaluates expressions with frequent checkpoints."}
{"t": "task", "id": "t-11f1", "spec": "debug-dashboard-validation.md", "name": "Add synchronization for async handle is_closed callback fields", "s": "p", "notes": "Root cause: handle->is_closed and handle->is_closed_ctx are non-atomic fields read by valk_async_is_resource_closed() which is called from libuv thread in valk_async_handle_fail/complete, while user code on main thread may write these fields after receiving the handle. Approach: Either (1) make is_closed and is_closed_ctx atomic with appropriate memory ordering, or (2) ensure all reads/writes to these fields happen on the libuv thread by queueing setter operations. Option 1 is simpler - use _Atomic for the function pointer and context, with acquire/release semantics.", "accept": "Run make test-valk-tsan and verify no races reported for aio_http2_client.c lines 299-341. Verify existing tests still pass with make test."}
{"t": "task", "id": "t-kici", "spec": "debug-dashboard-validation.md", "name": "Add synchronization for concurrent env access during on-demand evacuation", "s": "p", "notes": "Root cause: valk_evacuate_to_heap() runs outside STW coordination and can modify env->vals.items and env->symbols.items while valk_lenv_get reads them. Options: (1) Add per-env rwlock (read in lenv_get, write in evacuate_env) - simple but adds lock overhead to hot path; (2) Use atomic pointer stores in evacuation with atomic loads in lenv_get - minimal overhead but complex; (3) Make evacuate_to_heap only copy values without modifying original env, returning a new env pointer. Recommended: Option 2 with relaxed atomics.", "accept": "1. TSAN test with concurrent env access during evacuation shows no races. 2. make test passes. 3. No measurable performance regression in env lookup microbenchmark."}
{"t": "task", "id": "t-e4s9", "spec": "debug-dashboard-validation.md", "name": "Call LVAL_REF finalizers during heap destruction", "s": "p", "notes": "Root cause: valk_gc_heap2_destroy() unmaps pages and large objects without iterating through allocated slots to call finalizers. The sweep functions (valk_gc_sweep_page2) correctly call v->ref.free(v->ref.ptr) for LVAL_REF types, but destroy bypasses this. Fix: In valk_gc_heap2_destroy(), before unmapping pages, iterate through all allocated slots in each page allocation bitmap and call finalizers for any LVAL_REF objects.", "accept": "Run make test-valk-asan with a test that creates and uses atoms. ASAN should report 0 leaks from parser.c:4011."}
{"t": "task", "id": "t-jco8", "spec": "debug-dashboard-validation.md", "name": "Add STW synchronization before checkpoint in REPL", "s": "p", "notes": "Root cause: valk_checkpoint() mutates shared environment data structures without synchronization. When called from REPL between expressions, the event loop thread may be concurrently accessing these environments via callback closures. Fix: Before calling valk_checkpoint() in repl.c, request STW and wait for event loop thread to reach safe point (using existing valk_gc_coord mechanism). Alternative: make checkpoint mutations atomic or use per-environment locks (more complex, lower performance).", "accept": "1. TSAN reports no races when running valk programs that use both REPL evaluation and AIO timers/callbacks. 2. Add test: start interval timer, then run expressions that trigger checkpoint, verify no TSAN warnings. 3. Ensure checkpoint still correctly evacuates values."}
{"t": "task", "id": "t-k8c5", "spec": "debug-dashboard-validation.md", "name": "Add TSAN annotations to chase-lev deque for async task queue", "s": "p", "notes": "The chase-lev deque in aio_chase_lev.c uses atomic_thread_fence for synchronization which TSAN does not understand. Add __tsan_release in valk_chase_lev_push after the release fence (line 61) and __tsan_acquire in valk_chase_lev_steal after successfully obtaining an item. Use conditional compilation (#ifdef __SANITIZE_THREAD__) to avoid overhead in non-TSAN builds. The annotations should be on the item pointer, not the deque itself, to properly inform TSAN about data dependencies.", "accept": "1. Run make test with TSAN flags with no races reported in aio_http2_client.c:299-341. 2. Verify the chase-lev queue tests still pass. 3. Verify HTTP2 client integration tests pass under TSAN."}
{"t": "task", "id": "t-hbaq", "spec": "debug-dashboard-validation.md", "name": "Call LVAL_REF destructors in valk_gc_heap2_destroy before unmapping", "s": "p", "notes": "In valk_gc_heap2_destroy (gc.c:2566), before unmapping the heap base and large objects, iterate through all allocated slots in all pages and call v->ref.free(v->ref.ptr) for any LVAL_REF with non-null free. Same for large objects - check if they are LVAL_REFs before munmap. Can reuse the finalization logic pattern from valk_gc_sweep_page2 (gc.c:3024-3028).", "accept": "1) make test-valk-asan passes with no leak reports for atoms, 2) ASAN reports 0 bytes leaked from valk_builtin_atom allocations, 3) Existing tests pass"}
