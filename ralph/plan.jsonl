{"t": "spec", "spec": "eliminate-global-state.md"}
{"t": "task", "id": "t-5xpy", "spec": "eliminate-global-state.md", "name": "Refactor test/run to use explicit context", "s": "d", "notes": "Currently test/run reads global variables (*test-suite-name*, *test-skip-suite*, *test-skip-reason*, *test-debug*, *test-expected-exit*) and copies them into ctx at lines 138-143. Refactor to accept optional config argument or use builder pattern. The ctx is already threaded through foldl properly, but initial values come from globals.", "accept": "test/run works without reading any *test-* globals except *test-registry*", "done_at": "a23730e"}
{"t": "task", "id": "t-yuqv", "spec": "eliminate-global-state.md", "name": "Refactor test config setters to return ctx", "s": "p", "notes": "Functions test/debug, test/suite, test/skip, test/expect-exit currently mutate globals. Refactor to take ctx and return updated ctx. E.g. (test/suite ctx \"My Suite\") -> updated ctx. Existing callers use global mutation pattern, need migration.", "accept": "test/debug, test/suite, test/skip, test/expect-exit take ctx as first arg and return updated ctx", "deps": ["t-5xpy"]}
{"t": "task", "id": "t-0mjw", "spec": "eliminate-global-state.md", "name": "Refactor test registration to use explicit list", "s": "p", "notes": "test/define currently appends to global *test-registry*. Two options: (1) builder pattern - (test/add suite test) returns updated suite, or (2) inline list - (test/run (list (test ...) (test ...))). Spec suggests builder pattern. test/run already accepts optional test list arg.", "accept": "Tests can be run without using *test-registry* global", "deps": ["t-yuqv"]}
{"t": "task", "id": "t-sawa", "spec": "eliminate-global-state.md", "name": "Refactor test/run-async to use explicit context", "s": "p", "notes": "test/run-async currently reads *test-suite-name*, *test-expected-exit*, *test-async-registry* globals. Already uses atoms for counters (good). Refactor to accept optional config/test-list arguments like test/run.", "accept": "test/run-async works without reading global config variables", "deps": ["t-0mjw"]}
{"t": "task", "id": "t-sv0m", "spec": "eliminate-global-state.md", "name": "Refactor async test registration to use explicit list", "s": "p", "notes": "test/async currently appends to global *test-async-registry*. Same pattern as sync tests - refactor to builder or inline list. test/run-async already accepts optional test list.", "accept": "Async tests can be run without using *test-async-registry* global", "deps": ["t-sawa"]}
{"t": "task", "id": "t-72xs", "spec": "eliminate-global-state.md", "name": "Migrate test files to new test framework API", "s": "p", "notes": "After framework refactoring, migrate all test/*.valk files from (test/define ...) + (test/run) pattern to builder or inline list pattern. About 72 test files to update.", "accept": "All tests pass using new API, no test file uses test/define or global mutation", "deps": ["t-sv0m"]}
{"t": "task", "id": "t-lfzd", "spec": "eliminate-global-state.md", "name": "Remove deprecated global variables from test.valk", "s": "p", "notes": "After migration complete, remove: *test-registry*, *test-suite-name*, *test-skip-suite*, *test-skip-reason*, *test-debug*, *test-expected-exit*, *test-async-registry*. Keep atoms: *test-async-pending-atom*, *test-async-passed-atom*, *test-async-failed-atom*.", "accept": "test.valk has only 3 atom globals, no mutable def globals", "deps": ["t-72xs"]}
{"t": "task", "id": "t-cmzg", "spec": "eliminate-global-state.md", "name": "Update check-no-globals.py allowlist", "s": "p", "notes": "After globals removed, update ALLOWED_PATTERNS in bin/check-no-globals.py to remove allowlisted test framework globals. Only atoms should remain allowed.", "accept": "check-no-globals.py passes without any non-atom test.valk allowlist entries", "deps": ["t-lfzd"]}
{"t": "task", "id": "t-2lca", "spec": "eliminate-global-state.md", "name": "Refactor *async-run-result* in async_monadic.valk", "s": "p", "notes": "src/async_monadic.valk uses *async-run-result* for local capture in async/run function. While currently allowlisted and technically safe (single-threaded sync wrapper), it violates the no-global-mutation principle. Refactor to use different pattern.", "accept": "async/run works without *async-run-result* global"}
