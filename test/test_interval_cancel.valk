; Test aio/interval cancellation functionality
; Verifies that aio/interval returns a handle and aio/cancel works

(load "src/prelude.valk")

(def {aio} (aio/start))

(println "=== Testing aio/interval Cancellation ===")

; Test 1: aio/interval returns a handle
(def {interval-handle} (aio/interval aio 20 (\ {} {
  nil
})))

(if (handle? interval-handle)
  (println "  aio/interval returns a handle")
  (do
    (println "  FAIL: aio/interval did not return a handle")
    (aio/stop aio)
    (exit 1)))

; Let the interval run for a bit then test cancellation via aio/then + aio/sleep
(aio/then (aio/sleep aio 100) (\ {_} {
  ; Test 2: Cancel the interval
  (= {cancel-result} (aio/cancel interval-handle))
  (if (== cancel-result (quote :true))
    (println "  aio/cancel returned :true")
    (do
      (println "  FAIL: aio/cancel did not return :true")
      (aio/stop aio)
      (exit 1)))
  
  ; Test 3: Check if cancelled
  (= {is-cancelled} (aio/cancelled? interval-handle))
  (if (== is-cancelled (quote :true))
    (println "  Interval handle is marked as cancelled")
    (do
      (println "  FAIL: Interval handle not marked as cancelled")
      (aio/stop aio)
      (exit 1)))
  
  ; Test 4: Verify status is cancelled
  (= {status} (aio/status interval-handle))
  (if (== status (quote :cancelled))
    (println "  Interval status is :cancelled")
    (do
      (print "  FAIL: Interval status is not :cancelled, got:" status)
      (aio/stop aio)
      (exit 1)))
  
  ; All tests passed
  (println "  All tests passed!")
  (aio/stop aio)
}))

(aio/run aio)
(exit 0)
