; Comprehensive tests for monadic async API
; Tests all combinators to prevent regressions

(load "src/prelude.valk")
(load "src/async_monadic.valk")

(print "=== Monadic Async API Test Suite ===\n")

; Test utilities - mock async operations
(def {double-async} (\ {x k} {
  (k (* x 2))
}))

(def {add-async} (\ {a b k} {
  (k (+ a b))
}))

(def {is-even-async} (\ {x k} {
  (k (== (mod x 2) 0))
}))

(def {sum-async} (\ {acc x k} {
  (k (+ acc x))
}))

(def {log-async} (\ {msg k} {
  (print "  [LOG]" msg)
  (k msg)
}))

; Track test results
(def {passed} 0)
(def {failed} 0)

(def {assert-eq} (\ {name expected actual} {
  (if (== expected actual)
    {(do
       (print "✓" name)
       (= {passed} (+ passed 1)))}
    {(do
       (print "✗" name "- Expected:" expected "Got:" actual)
       (= {failed} (+ failed 1)))})
}))

; === Test 1: async-pure ===
(print "\nTest 1: async-pure")
(def {t1} (run-async (async-pure 42)))
(assert-eq "async-pure wraps value" 42 t1)

; === Test 2: async-bind (flatMap) ===
(print "\nTest 2: async-bind")
(def {t2} (run-async (async-bind (async-pure 21) (\ {x} {(async-pure (* x 2))}))))
(assert-eq "async-bind chains operations" 42 t2)

; === Test 3: async-map-list ===
(print "\nTest 3: async-map-list")
(def {t3} (run-async (async-map-list double-async (list 1 2 3 4 5))))
(assert-eq "async-map-list maps over list" (list 2 4 6 8 10) t3)

(def {t3b} (run-async (async-map-list double-async ())))
(assert-eq "async-map-list handles empty list" () t3b)

; === Test 4: async-filter-list ===
(print "\nTest 4: async-filter-list")
(def {t4} (run-async (async-filter-list is-even-async (list 1 2 3 4 5 6))))
(assert-eq "async-filter-list filters correctly" (list 2 4 6) t4)

(def {t4b} (run-async (async-filter-list is-even-async ())))
(assert-eq "async-filter-list handles empty list" () t4b)

; === Test 5: async-fold-list ===
(print "\nTest 5: async-fold-list")
(def {t5} (run-async (async-fold-list sum-async 0 (list 1 2 3 4 5))))
(assert-eq "async-fold-list sums correctly" 15 t5)

(def {t5b} (run-async (async-fold-list sum-async 100 ())))
(assert-eq "async-fold-list handles empty list" 100 t5b)

; === Test 6: async-collect ===
(print "\nTest 6: async-collect")
(def {ops} (list
  (async-pure 10)
  (async-pure 20)
  (async-pure 30)))
(def {t6} (run-async (async-collect ops)))
(assert-eq "async-collect gathers results" (list 10 20 30) t6)

; === Test 7: async-sequence ===
(print "\nTest 7: async-sequence")
(def {seq-ops} (list
  (async-pure 1)
  (async-pure 2)
  (async-pure 3)))
(def {t7} (run-async (async-sequence seq-ops)))
(assert-eq "async-sequence returns last result" 3 t7)

; === Test 8: async-race ===
(print "\nTest 8: async-race")
(def {race-ops} (list
  (async-pure 100)
  (async-pure 200)))
(def {t8} (run-async (async-race race-ops)))
(assert-eq "async-race returns first result" 100 t8)

; === Test 9: async-when ===
(print "\nTest 9: async-when")
(def {t9a} (run-async (async-when 1 (async-pure 42))))
(assert-eq "async-when executes when true" 42 t9a)

(def {t9b} (run-async (async-when 0 (async-pure 42))))
(assert-eq "async-when skips when false" nil t9b)

; === Test 10: async-unless ===
(print "\nTest 10: async-unless")
(def {t10a} (run-async (async-unless 0 (async-pure 42))))
(assert-eq "async-unless executes when false" 42 t10a)

(def {t10b} (run-async (async-unless 1 (async-pure 42))))
(assert-eq "async-unless skips when true" nil t10b)

; === Test 11: async-tap ===
(print "\nTest 11: async-tap")
(def {t11} (run-async (async-tap 99 log-async)))
(assert-eq "async-tap returns original value" 99 t11)

; === Test 12: async-const ===
(print "\nTest 12: async-const")
(def {t12} (run-async (async-const 77 (async-pure 999))))
(assert-eq "async-const returns constant" 77 t12)

; === Test 13: async-pipe ===
(print "\nTest 13: async-pipe")
(def {add-ten-async} (\ {x k} {(k (+ x 10))}))
(def {square-async} (\ {x k} {(k (* x x))}))

(def {t13} (run-async (async-pipe 5 (list double-async add-ten-async square-async))))
; (5 * 2 + 10) ^ 2 = 400
(assert-eq "async-pipe composes operations" 400 t13)

; === Test 14: async-compose ===
(print "\nTest 14: async-compose")
(def {composed} (async-compose double-async add-ten-async))
(def {t14} (run-async (composed 5)))
; 5 * 2 + 10 = 20
(assert-eq "async-compose creates composed function" 20 t14)

; === Test 15: async-try ===
(print "\nTest 15: async-try")
(def {t15} (run-async (async-try (async-pure 42))))
(assert-eq "async-try wraps success" (list "ok" 42) t15)

; === Test 16: async-zip-with ===
(print "\nTest 16: async-zip-with")
(def {t16} (run-async (async-zip-with add-async (list 1 2 3) (list 10 20 30))))
(assert-eq "async-zip-with combines lists" (list 11 22 33) t16)

(def {t16b} (run-async (async-zip-with add-async (list 1 2 3) (list 10 20))))
(assert-eq "async-zip-with handles different lengths" (list 11 22) t16b)

; === Test 17: async-replicate ===
(print "\nTest 17: async-replicate")
(def {t17} (run-async (async-replicate 4 (async-pure 7))))
(assert-eq "async-replicate repeats operation" (list 7 7 7 7) t17)

; === Test 18: async-take ===
(print "\nTest 18: async-take")
(def {counter-async} (async-pure 1))
(def {t18} (run-async (async-take 3 counter-async)))
(assert-eq "async-take takes n results" (list 1 1 1) t18)

; === Test 19: Complex composition ===
(print "\nTest 19: Complex composition")
; Map, filter, then fold
(def {t19-mapped} (run-async (async-map-list double-async (list 1 2 3 4 5 6))))
(def {t19-filtered} (run-async (async-filter-list is-even-async t19-mapped)))
(def {t19-result} (run-async (async-fold-list sum-async 0 t19-filtered)))
; double: (2 4 6 8 10 12)
; filter even: (2 4 6 8 10 12) - all even
; sum: 42
(assert-eq "complex composition works" 42 t19-result)

; === Test 20: Nested async operations ===
(print "\nTest 20: Nested async operations")
(def {fetch-user-async} (\ {id k} {(k (list "user" id))}))
(def {fetch-posts-async} (\ {user k} {
  (def {user-id} (nth 1 user))
  (k (list "posts" user-id 3))
}))

(def {t20} (run-async (async-bind
  (fetch-user-async 42)
  (\ {user} {(fetch-posts-async user)}))))
(assert-eq "nested async operations work" (list "posts" 42 3) t20)

; === Test 21: async-all (alias test) ===
(print "\nTest 21: async-all")
(def {t21} (run-async (async-all (list
  (async-pure 1)
  (async-pure 2)
  (async-pure 3)))))
(assert-eq "async-all collects all results" (list 1 2 3) t21)

; === Test 22: Empty operations ===
(print "\nTest 22: Empty operations")
(def {t22a} (run-async (async-collect ())))
(assert-eq "async-collect handles empty list" () t22a)

(def {t22b} (run-async (async-sequence ())))
(assert-eq "async-sequence handles empty list" nil t22b)

; === Test 23: Large list performance ===
(print "\nTest 23: Large list operations")
(def {large-list} (list 1 2 3 4 5 6 7 8 9 10))
(def {t23} (run-async (async-map-list double-async large-list)))
(assert-eq "large list map works" (list 2 4 6 8 10 12 14 16 18 20) t23)

; === Test 24: Chained bind operations ===
(print "\nTest 24: Chained bind")
(def {t24} (run-async
  (async-bind (async-pure 5)
    (\ {x} {(async-bind (async-pure (* x 2))
      (\ {y} {(async-pure (+ y 10))}))}))))
; 5 * 2 + 10 = 20
(assert-eq "chained bind works" 20 t24)

; === Test 25: async-traverse (alias test) ===
(print "\nTest 25: async-traverse")
(def {t25} (run-async (async-traverse double-async (list 5 10 15))))
(assert-eq "async-traverse maps correctly" (list 10 20 30) t25)

; === Summary ===
(print "\n" (repeat "=" 50))
(print "Test Results:")
(print "  Passed:" passed)
(print "  Failed:" failed)
(print "  Total: " (+ passed failed))
(print (repeat "=" 50))

(if (== failed 0)
  {(do
    (print "\n✓✓✓ All tests passed! ✓✓✓")
    (print "Monadic async API is working correctly."))}
  {(do
    (print "\n✗✗✗ Some tests failed ✗✗✗")
    (print "Please review the failures above."))})

(shutdown 0)
