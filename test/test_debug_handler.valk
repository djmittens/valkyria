; Debug Handler Route Matching Tests
; Tests that aio/debug-handle-request routes requests correctly

(load "src/prelude.valk")
(load "src/modules/test.valk")
(load "src/modules/aio/debug.valk")

(def {aio} (aio/start))

(def {test-handler} (aio/debug-handler aio))

(def {server} (http2/server-listen aio 0 test-handler))
(def {TEST_PORT} (http2/server-port server))

(fun {run-tests-sequentially aio tests on-all-done}
  {(= {total} (len tests))
   (= {passed} (atom 0))
   (= {failed} (atom 0))
   (= {current-idx} (atom 0))

   (fun {run-next-test} {
     (= {idx} (atom/get current-idx))
     (if (>= idx total)
       (on-all-done (atom/get passed) (atom/get failed))
       (do
         (debug/reset-state)
         (= {test} (nth idx tests))
         (= {test-name} (eval (head test)))
         (= {test-body} (eval (head (tail test))))
         (= {start-time} (time-us {}))
         (= {timed-out} (atom 0))
         (= {timer-handle} (aio/schedule aio 5000 (\ {} {
           (if (== (atom/get timed-out) 0)
             (do
               (atom/set! timed-out 1)
               (printf "  ") (*test-pad-dots* test-name 97) (printf "  TIMEOUT\n")
               (atom/add! failed 1)
               (atom/add! current-idx 1)
               (aio/schedule aio 0 (\ {} (run-next-test))))
             nil)})))
         (= {done-fn} (\ {result} {
           (= {prev-state} (atom/get timed-out))
           (atom/set! timed-out 2)
           (if (!= prev-state 0)
             nil
             (do
               (aio/cancel timer-handle)
               (= {end-time} (time-us {}))
               (= {elapsed} (- end-time start-time))
               (if result
                 (do
                   (printf "  ") (*test-pad-dots* test-name 97) (printf "  PASS : in %ld(us)\n" elapsed)
                   (atom/add! passed 1))
                 (do
                   (printf "  ") (*test-pad-dots* test-name 97) (printf "  FAIL : in %ld(us)\n" elapsed)
                   (atom/add! failed 1)))
               (atom/add! current-idx 1)
               (aio/schedule aio 0 (\ {} (run-next-test)))))}))
         (aio/schedule aio 0 (\ {} (test-body done-fn)))))})
   (run-next-test)})

(fun {str-contains? haystack needle}
  {(> (len (str/split haystack needle)) 1)})

(fun {get-header headers name} {
  if (nil? headers)
    {nil}
    {if (== (head (head headers)) name)
      {head (tail (head headers))}
      {get-header (tail headers) name}}
})

(fun {str-starts-with? s prefix}
  {(= {prefix-len} (len prefix))
   (if (< (len s) prefix-len)
     {false}
     {(== (head (str/split s (make-string prefix-len (ord (head (str/split prefix "")))))) "")})})

(fun {first-char s}
  {(if (> (len s) 0)
     {(head (str/split (str (make-string 1 (ord s))) ""))}
     {""})})

(def {main-tests} (list
  (test-async "/debug returns HTML dashboard" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "<!DOCTYPE"))
             {(done true)}
             {(do
               (print "Expected: status=200, HTML body")
               (print "Got status:" status)
               (done false)
             )})})
      }))
  }))

  (test-async "/debug/ returns HTML dashboard" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "<!DOCTYPE"))
             {(done true)}
             {(do
               (print "Expected: status=200, HTML body")
               (print "Got status:" status)
               (done false)
             )})})
      }))
  }))

  (test-async "/debug/metrics returns JSON with aio_metrics" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/metrics"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "aio_metrics"))
             {(done true)}
             {(do
               (print "Expected: status=200, JSON with aio_metrics")
               (print "Got status:" status)
               (done false)
             )})})
      }))
  }))

  (test-async "/debug/metrics/state returns diagnostics JSON" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/metrics/state"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "\"metrics\""))
             {(done true)}
             {(do
               (print "Expected: status=200, JSON with metrics key")
               (print "Got status:" status)
               (done false)
             )})})
      }))
  }))

  (test-async "/debug/metrics/state has metrics.aio structure" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/metrics/state"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "\"aio\":"))
             {(done true)}
             {(do
               (print "Expected: JSON with metrics.aio key")
               (print "Got body:" body)
               (done false)
             )})})
      }))
  }))

  (test-async "/debug/metrics/state has metrics.modular structure" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/metrics/state"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "\"modular\":"))
             {(done true)}
             {(do
               (print "Expected: JSON with metrics.modular key")
               (print "Got body:" body)
               (done false)
             )})})
      }))
  }))

  (test-async "/debug/metrics/state has metrics.vm structure" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/metrics/state"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "\"vm\":"))
             {(done true)}
             {(do
               (print "Expected: JSON with metrics.vm key")
               (print "Got body:" body)
               (done false)
             )})})
      }))
  }))

  (test-async "/debug/metrics/state has metrics.registry structure" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/metrics/state"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "\"registry\":"))
             {(done true)}
             {(do
               (print "Expected: JSON with metrics.registry key")
               (print "Got body:" body)
               (done false)
             )})})
      }))
  }))

  (test-async "/debug/metrics/state has memory structure" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/metrics/state"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "\"memory\":"))
             {(done true)}
             {(do
               (print "Expected: JSON with memory key")
               (print "Got body:" body)
               (done false)
             )})})
      }))
  }))

  (test-async "/debug/metrics/state returns Content-Type: application/json" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/metrics/state"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {headers} (http2/response-headers resp))
           (= {ct} (get-header headers "content-type"))
           (if (== ct "application/json")
             {(done true)}
             {(do
               (print "Expected: Content-Type: application/json")
               (print "Got:" ct)
               (done false)
             )})})
      }))
  }))

  (test-async "/debug/metrics/state returns Cache-Control: no-cache" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/metrics/state"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {headers} (http2/response-headers resp))
           (= {cc} (get-header headers "cache-control"))
           (if (== cc "no-cache, no-store, must-revalidate")
             {(done true)}
             {(do
               (print "Expected: Cache-Control: no-cache, no-store, must-revalidate")
               (print "Got:" cc)
               (done false)
             )})})
      }))
  }))

  (test-async "/metrics returns Content-Type: text/plain; version=0.0.4" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/metrics"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {headers} (http2/response-headers resp))
           (= {ct} (get-header headers "content-type"))
           (if (== ct "text/plain; version=0.0.4")
             {(done true)}
             {(do
               (print "Expected: Content-Type: text/plain; version=0.0.4")
               (print "Got:" ct)
               (done false)
             )})})
      }))
  }))

  (test-async "/metrics returns Prometheus format" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/metrics"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (== status "200")
             {(done true)}
             {(do
               (print "Expected: status=200")
               (print "Got status:" status)
               (done false)
             )})})
      }))
  }))

  (test-async "/metrics contains valk_gc_ metrics" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/metrics"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (and (str-contains? body "valk_gc_cycles_total")
                         (str-contains? body "valk_gc_heap_used_bytes")))
             {(done true)}
             {(do
               (print "Expected: body to contain valk_gc_ metrics")
               (print "Got body snippet:" (if (> (len body) 300) (str (str/slice body 0 300) "...") body))
               (done false)
             )})})
      }))
  }))

  (test-async "/metrics contains http_ metrics" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/metrics"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "http_"))
             {(done true)}
             {(do
               (print "Expected: body to contain http_ metrics")
               (print "Got body snippet:" (if (> (len body) 500) (str (str/slice body 0 500) "...") body))
               (done false)
             )})})
      }))
  }))

  (test-async "/metrics has valid Prometheus HELP lines" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/metrics"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "# HELP"))
             {(done true)}
             {(do
               (print "Expected: body to contain '# HELP' lines")
               (print "Got body snippet:" (if (> (len body) 300) (str (str/slice body 0 300) "...") body))
               (done false)
             )})})
      }))
  }))

  (test-async "/metrics has valid Prometheus TYPE lines" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/metrics"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "# TYPE"))
             {(done true)}
             {(do
               (print "Expected: body to contain '# TYPE' lines")
               (print "Got body snippet:" (if (> (len body) 300) (str (str/slice body 0 300) "...") body))
               (done false)
             )})})
      }))
  }))

  (test-async "/metrics TYPE lines have valid metric types" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/metrics"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (= {has-counter} (str-contains? body "counter"))
           (= {has-gauge} (str-contains? body "gauge"))
           (if (and (== status "200")
                    (or has-counter has-gauge))
             {(done true)}
             {(do
               (print "Expected: body to contain 'counter' or 'gauge' type declarations")
               (print "has-counter:" has-counter "has-gauge:" has-gauge)
               (done false)
             )})})
      }))
  }))

  (test-async "/metrics contains valk_eval_total metric" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/metrics"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "valk_eval_total"))
             {(done true)}
             {(do
               (print "Expected: body to contain valk_eval_total metric")
               (done false)
             )})})
      }))
  }))

  (test-async "/metrics contains valk_loop_iterations_total metric" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/metrics"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "valk_loop_iterations_total"))
             {(done true)}
             {(do
               (print "Expected: body to contain valk_loop_iterations_total metric")
               (done false)
             )})})
      }))
  }))

   (test-async "/debug/diagnostics/memory SSE endpoint responds" (\ {done} {
    ; Create a custom handler that opens SSE and closes after first event
    (= {test-closed} (atom false))
    (= {test-sse-respond-handler}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/test-sse-respond")
          {(do
            (= {stream} (sse/open req))
            (stream/on-close stream (\ {} {(atom/set! test-closed true)}))
            (stream/write stream "event: test\ndata: ok\n\n")
            (stream/close stream)
            :deferred)}
          {(test-handler req)})}))
    (= {test-server-respond} (http2/server-listen aio 0 test-sse-respond-handler))
    (= {test-port-respond} (http2/server-port test-server-respond))
    (http2/client-request aio "127.0.0.1" test-port-respond "/test-sse-respond"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {body} (http2/response-body resp))
           (if (str-contains? body "event: test")
             {(done true)}
             {(do (print "Expected SSE event") (done false))})})}))
  }))

  (test-async "/debug/diagnostics/memory SSE first event is 'diagnostics'" (\ {done} {
    (= {captured-body} (atom ""))
    (= {closed} (atom false))
    (= {test-sse-handler}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/test-sse-capture")
          {(do
            (= {stream} (sse/open req))
            (= {captured-sys} aio)
            (= {first-sent} (atom false))
            (stream/on-close stream (\ {} {(atom/set! closed true)}))
            (aio/interval captured-sys 100 (\ {}
              {(if (atom/get closed)
                :stop
                (if (atom/get first-sent)
                  (do
                    (= {delta} (aio/debug-diagnostics-delta captured-sys))
                    (stream/write stream (str "event: diagnostics-delta\ndata: " delta "\n\n"))
                    (stream/close stream)
                    :stop)
                  (do
                    (atom/set! first-sent true)
                    (= {state} (aio/debug-diagnostics-state captured-sys))
                    (stream/write stream (str "event: diagnostics\ndata: " state "\n\n")))))}))
            :deferred)}
          {(test-handler req)})}))
    (= {test-server} (http2/server-listen aio 0 test-sse-handler))
    (= {test-port} (http2/server-port test-server))
    (http2/client-request aio "127.0.0.1" test-port "/test-sse-capture"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {body} (http2/response-body resp))
           (if (str-contains? body "event: diagnostics\n")
             {(done true)}
             {(do
               (print "Expected: body to contain 'event: diagnostics'")
               (print "Got body:" (if (> (len body) 200) (str (str/slice body 0 200) "...") body))
               (done false)
             )})})}))
  }))

  (test-async "/debug/diagnostics/memory SSE second event is 'diagnostics-delta'" (\ {done} {
    (= {closed2} (atom false))
    (= {events-sent} (atom 0))
    (= {test-sse-handler2}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/test-sse-capture2")
          {(do
            (= {stream} (sse/open req))
            (= {captured-sys} aio)
            (stream/on-close stream (\ {} {(atom/set! closed2 true)}))
            (aio/interval captured-sys 100 (\ {}
              {(if (atom/get closed2)
                :stop
                (if (< (atom/get events-sent) 2)
                  (do
                    (if (== (atom/get events-sent) 0)
                      (do
                        (= {state} (aio/debug-diagnostics-state captured-sys))
                        (stream/write stream (str "event: diagnostics\ndata: " state "\n\n")))
                      (do
                        (= {delta} (aio/debug-diagnostics-delta captured-sys))
                        (stream/write stream (str "event: diagnostics-delta\ndata: " delta "\n\n"))))
                    (atom/set! events-sent (+ (atom/get events-sent) 1)))
                  (do
                    (stream/close stream)
                    :stop)))}))
            :deferred)}
          {(test-handler req)})}))
    (= {test-server2} (http2/server-listen aio 0 test-sse-handler2))
    (= {test-port2} (http2/server-port test-server2))
    (http2/client-request aio "127.0.0.1" test-port2 "/test-sse-capture2"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {body} (http2/response-body resp))
           (if (str-contains? body "event: diagnostics-delta\n")
             {(done true)}
             {(do
               (print "Expected: body to contain 'event: diagnostics-delta'")
               (print "Got body:" (if (> (len body) 200) (str (str/slice body 0 200) "...") body))
               (done false)
             )})})}))
  }))

  (test-async "/debug/diagnostics/memory SSE events have valid JSON" (\ {done} {
    (= {closed3} (atom false))
    (= {events-sent3} (atom 0))
    (= {test-sse-handler3}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/test-sse-capture3")
          {(do
            (= {stream} (sse/open req))
            (= {captured-sys} aio)
            (stream/on-close stream (\ {} {(atom/set! closed3 true)}))
            (aio/interval captured-sys 100 (\ {}
              {(if (atom/get closed3)
                :stop
                (if (< (atom/get events-sent3) 2)
                  (do
                    (if (== (atom/get events-sent3) 0)
                      (do
                        (= {state} (aio/debug-diagnostics-state captured-sys))
                        (stream/write stream (str "event: diagnostics\ndata: " state "\n\n")))
                      (do
                        (= {delta} (aio/debug-diagnostics-delta captured-sys))
                        (stream/write stream (str "event: diagnostics-delta\ndata: " delta "\n\n"))))
                    (atom/set! events-sent3 (+ (atom/get events-sent3) 1)))
                  (do
                    (stream/close stream)
                    :stop)))}))
            :deferred)}
          {(test-handler req)})}))
    (= {test-server3} (http2/server-listen aio 0 test-sse-handler3))
    (= {test-port3} (http2/server-port test-server3))
    (http2/client-request aio "127.0.0.1" test-port3 "/test-sse-capture3"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {body} (http2/response-body resp))
           (= {has-diagnostics} (str-contains? body "event: diagnostics\n"))
           (= {has-delta} (str-contains? body "event: diagnostics-delta\n"))
           (= {has-metrics} (str-contains? body "\"metrics\":"))
           (= {has-memory} (str-contains? body "\"memory\":"))
           (if (and has-diagnostics (and has-delta (and has-metrics has-memory)))
             {(done true)}
             {(do
               (print "Expected: both event types with metrics and memory keys")
               (print "has-diagnostics:" has-diagnostics)
               (print "has-delta:" has-delta)
               (print "has-metrics:" has-metrics)
               (print "has-memory:" has-memory)
               (done false)
             )})})}))
  }))

  (test-async "/debug/slab/buckets returns JSON" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/slab/buckets"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "{"))
             {(done true)}
             {(do
               (print "Expected: status=200, JSON body")
               (print "Got status:" status)
               (done false)
             )})})
      }))
  }))

  (test-async "/unknown routes redirect to /debug/" (\ {done} {
    (http2/client-request aio "127.0.0.1" TEST_PORT "/debug/unknown/route"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {status} (http2/response-status resp))
           (= {body} (http2/response-body resp))
           (if (and (== status "200")
                    (str-contains? body "url=/debug/"))
             {(done true)}
             {(do
               (print "Expected: status=200, redirect meta tag to /debug/")
               (print "Got status:" status)
               (print "Got body:" body)
               (done false)
             )})})
      }))
  }))

  (test-async "SSE handler lifecycle: reconnect works after disconnect" (\ {done} {
    (= {closed-lifecycle} (atom false))
    (= {events-sent-lifecycle} (atom 0))
    (= {connection-count} (atom 0))
    (= {test-sse-lifecycle-handler}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/test-sse-lifecycle")
          {(do
            (atom/set! connection-count (+ (atom/get connection-count) 1))
            (= {stream} (sse/open req))
            (= {captured-sys} aio)
            (= {local-closed} (atom false))
            (stream/on-close stream (\ {} {(atom/set! local-closed true)}))
            (aio/interval captured-sys 50 (\ {}
              {(if (atom/get local-closed)
                :stop
                (do
                  (= {state} (aio/debug-diagnostics-state captured-sys))
                  (stream/write stream (str "event: diagnostics\ndata: " state "\n\n"))
                  (stream/close stream)
                  :stop))}))
            :deferred)}
          {(test-handler req)})}))
    (= {test-server-lifecycle} (http2/server-listen aio 0 test-sse-lifecycle-handler))
    (= {test-port-lifecycle} (http2/server-port test-server-lifecycle))
    (http2/client-request aio "127.0.0.1" test-port-lifecycle "/test-sse-lifecycle"
      (\ {resp1} {
        (if (error? resp1)
          {(do (print "First connection error:" resp1) (done false))}
          {(= {body1} (http2/response-body resp1))
           (if (str-contains? body1 "event: diagnostics")
             {(aio/schedule aio 100 (\ {} {
               (http2/client-request aio "127.0.0.1" test-port-lifecycle "/test-sse-lifecycle"
                 (\ {resp2} {
                   (if (error? resp2)
                     {(do (print "Second connection error:" resp2) (done false))}
                     {(= {body2} (http2/response-body resp2))
                      (= {conns} (atom/get connection-count))
                      (if (and (str-contains? body2 "event: diagnostics") (== conns 2))
                        {(done true)}
                        {(do
                          (print "Expected: second connection to receive events, got" conns "connections")
                          (print "Body2:" (if (> (len body2) 100) (str (str/slice body2 0 100) "...") body2))
                          (done false)
                        )})})}))}))}
             {(do
               (print "First connection didn't receive event")
               (done false)
             )})})}))
  }))

  (test-async "SSE handler lifecycle: timer stops after disconnect (no duplicate events)" (\ {done} {
    (= {event-counter} (atom 0))
    (= {test-sse-timer-handler}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/test-sse-timer-stop")
          {(do
            (= {stream} (sse/open req))
            (= {captured-sys} aio)
            (= {local-closed} (atom false))
            (= {local-counter} event-counter)
            (stream/on-close stream (\ {} {(atom/set! local-closed true)}))
            (aio/interval captured-sys 30 (\ {}
              {(if (atom/get local-closed)
                :stop
                (do
                  (atom/set! local-counter (+ (atom/get local-counter) 1))
                  (= {state} (aio/debug-diagnostics-state captured-sys))
                  (stream/write stream (str "event: diagnostics\ndata: " state "\n\n"))
                  (if (>= (atom/get local-counter) 2)
                    (do (stream/close stream) :stop)
                    nil)))}))
            :deferred)}
          {(test-handler req)})}))
    (= {test-server-timer} (http2/server-listen aio 0 test-sse-timer-handler))
    (= {test-port-timer} (http2/server-port test-server-timer))
    (http2/client-request aio "127.0.0.1" test-port-timer "/test-sse-timer-stop"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Connection error:" resp) (done false))}
          {(= {body} (http2/response-body resp))
           (= {final-count} (atom/get event-counter))
           (aio/schedule aio 200 (\ {} {
             (= {post-count} (atom/get event-counter))
             (if (== final-count post-count)
               {(done true)}
               {(do
                 (print "Timer continued after disconnect! final:" final-count "post:" post-count)
                 (done false)
               )})}))})})
      )
  }))

  (test-async "debug/reset-state: session ID increments after reset" (\ {done} {
    (= {session-before} (atom/get debug/session-id))
    (debug/reset-state)
    (= {session-after} (atom/get debug/session-id))
    (if (== session-after (+ session-before 1))
      {(done true)}
      {(do
        (print "Expected session ID to increment by 1")
        (print "before:" session-before "after:" session-after)
        (done false))})
  }))

  (test-async "debug/reset-state: subscriber count resets to zero" (\ {done} {
    (debug/reset-state)
    (= {count-after-reset} (debug/get-subscriber-count))
    (if (== count-after-reset 0)
      {(done true)}
      {(do
        (print "Expected subscriber count to be 0 after reset")
        (print "Got:" count-after-reset)
        (done false))})
  }))

  (test-async "debug/reset-state: old subscribers stop after session ID change" (\ {done} {
    (debug/reset-state)
    (= {old-session} (atom/get debug/session-id))
    (= {event-count} (atom 0))
    (= {bc-reset-handler}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/bc-old-sub")
          {(do
            (= {stream} (sse/open req))
            (debug/subscribe aio stream)
            (aio/schedule aio 150 (\ {} {
              (debug/reset-state)
            }))
            (aio/schedule aio 500 (\ {} {(stream/close stream)}))
            :deferred)}
          {(test-handler req)})}))
    (= {bc-server-reset} (http2/server-listen aio 0 bc-reset-handler))
    (= {bc-port-reset} (http2/server-port bc-server-reset))
    (http2/client-request aio "127.0.0.1" bc-port-reset "/bc-old-sub"
      (\ {resp} {
        (= {new-session} (atom/get debug/session-id))
        (if (> new-session old-session)
          {(done true)}
          {(do
            (print "Expected session ID to have incremented after reset")
            (print "old:" old-session "new:" new-session)
            (done false))})}))
  }))
))

(def {broadcaster-tests} (list
  (test-async "Broadcaster: multiple connections both receive SSE events" (\ {done} {
    (debug/reset-state)
    (= {conn1-received} (atom false))
    (= {conn2-received} (atom false))
    (= {connections-complete} (atom 0))
    (= {bc-multi-handler}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/bc-multi")
          {(do
            (= {stream} (sse/open req))
            (debug/subscribe aio stream)
            (aio/schedule aio 400 (\ {} {(stream/close stream)}))
            :deferred)}
          {(test-handler req)})}))
    (= {bc-server} (http2/server-listen aio 0 bc-multi-handler))
    (= {bc-port} (http2/server-port bc-server))
    (http2/client-request aio "127.0.0.1" bc-port "/bc-multi"
      (\ {resp1} {
        (atom/set! connections-complete (+ (atom/get connections-complete) 1))
        (if (not (error? resp1))
          {(= {body} (http2/response-body resp1))
           (if (str-contains? body "event: diagnostics")
             {(atom/set! conn1-received true)}
             nil)}
          nil)
        (if (== (atom/get connections-complete) 2)
          {(if (and (atom/get conn1-received) (atom/get conn2-received))
             {(done true)}
             {(do (print "Expected both to receive events")
                  (print "conn1:" (atom/get conn1-received) "conn2:" (atom/get conn2-received))
                  (done false))})}
          nil)}))
    (http2/client-request aio "127.0.0.1" bc-port "/bc-multi"
      (\ {resp2} {
        (atom/set! connections-complete (+ (atom/get connections-complete) 1))
        (if (not (error? resp2))
          {(= {body} (http2/response-body resp2))
           (if (str-contains? body "event: diagnostics")
             {(atom/set! conn2-received true)}
             nil)}
          nil)
        (if (== (atom/get connections-complete) 2)
          {(if (and (atom/get conn1-received) (atom/get conn2-received))
             {(done true)}
             {(do (print "Expected both to receive events")
                  (print "conn1:" (atom/get conn1-received) "conn2:" (atom/get conn2-received))
                  (done false))})}
          nil)}))
    (aio/schedule aio 2000 (\ {} {
      (if (< (atom/get connections-complete) 2)
        {(do (print "Timeout: only" (atom/get connections-complete) "connections complete") (done false))}
        nil)}))
  }))

  (test-async "Broadcaster: subscriber receives events until disconnect" (\ {done} {
    (debug/reset-state)
    (= {bc-event-handler}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/bc-event")
          {(do
            (= {stream} (sse/open req))
            (debug/subscribe aio stream)
            (aio/schedule aio 350 (\ {} {(stream/close stream)}))
            :deferred)}
          {(test-handler req)})}))
    (= {bc-server2} (http2/server-listen aio 0 bc-event-handler))
    (= {bc-port2} (http2/server-port bc-server2))
    (http2/client-request aio "127.0.0.1" bc-port2 "/bc-event"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {body} (http2/response-body resp))
           (if (str-contains? body "event: diagnostics")
             {(done true)}
             {(do (print "No events received") (done false))})})}))
  }))

  (test-async "Broadcaster: subscriber count increases when subscribing" (\ {done} {
    (debug/reset-state)
    (= {count-before} (atom 0))
    (= {count-after} (atom 0))
    (= {bc-count-handler}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/bc-count")
          {(do
            (atom/set! count-before (debug/get-subscriber-count))
            (= {stream} (sse/open req))
            (debug/subscribe aio stream)
            (atom/set! count-after (debug/get-subscriber-count))
            (aio/schedule aio 300 (\ {} {(stream/close stream)}))
            :deferred)}
          {(test-handler req)})}))
    (= {bc-server3} (http2/server-listen aio 0 bc-count-handler))
    (= {bc-port3} (http2/server-port bc-server3))
    (http2/client-request aio "127.0.0.1" bc-port3 "/bc-count"
      (\ {resp} {
        (= {before} (atom/get count-before))
        (= {after} (atom/get count-after))
        (if (== after (+ before 1))
          {(done true)}
          {(do
            (print "Expected subscriber count to increase by 1")
            (print "before:" before "after:" after)
            (done false))})}))
  }))

  (test-async "Broadcaster: subscriber receives first and delta events" (\ {done} {
    (debug/reset-state)
    (= {bc-delta-handler}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/bc-delta")
          {(do
            (= {stream} (sse/open req))
            (debug/subscribe aio stream)
            (aio/schedule aio 450 (\ {} {(stream/close stream)}))
            :deferred)}
          {(test-handler req)})}))
    (= {bc-server4} (http2/server-listen aio 0 bc-delta-handler))
    (= {bc-port4} (http2/server-port bc-server4))
    (http2/client-request aio "127.0.0.1" bc-port4 "/bc-delta"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {body} (http2/response-body resp))
           (= {has-full} (str-contains? body "event: diagnostics\n"))
           (= {has-delta} (str-contains? body "event: diagnostics-delta\n"))
           (if (and has-full has-delta)
             {(done true)}
             {(do (print "Expected both full and delta events")
                  (print "has-full:" has-full "has-delta:" has-delta)
                  (done false))})})}))
  }))

  (test-async "debug/reset-state: new subscribers work after reset" (\ {done} {
    (debug/reset-state)
    (= {bc-new-handler}
      (\ {req} {
        (= {path} (req/path req))
        (if (== path "/bc-new-sub")
          {(do
            (= {stream} (sse/open req))
            (debug/subscribe aio stream)
            (aio/schedule aio 350 (\ {} {(stream/close stream)}))
            :deferred)}
          {(test-handler req)})}))
    (= {bc-server-new} (http2/server-listen aio 0 bc-new-handler))
    (= {bc-port-new} (http2/server-port bc-server-new))
    (http2/client-request aio "127.0.0.1" bc-port-new "/bc-new-sub"
      (\ {resp} {
        (if (error? resp)
          {(do (print "Error:" resp) (done false))}
          {(= {body} (http2/response-body resp))
           (if (str-contains? body "event: diagnostics")
             {(done true)}
             {(do
               (print "Expected new subscriber to receive events after reset")
               (print "Got body:" (if (> (len body) 100) (str (str/slice body 0 100) "...") body))
               (done false))})})}))
  }))
))

(def {*main-passed*} (atom 0))
(def {*main-failed*} (atom 0))
(def {*bc-passed*} (atom 0))
(def {*bc-failed*} (atom 0))
(def {*main-pending*} (atom 0))

(fun {run-main-tests-then-broadcaster aio main-tests broadcaster-tests} {
  (= {main-total} (len main-tests))
  (atom/set! *main-pending* main-total)
  (= {main-timeout-ms} 5000)

  (printf "üß™ [%ld/%ld] Debug Handler Route Matching (main tests)\n" main-total main-total)

  (fun {start-one-main-test test} {
    (= {test-name} (eval (head test)))
    (= {test-body} (eval (head (tail test))))
    (= {start-time} (time-us {}))
    (= {timed-out} (atom 0))

    (= {timer-handle} (aio/schedule aio main-timeout-ms (\ {} {
      (= {prev} (atom/get timed-out))
      (if (== prev 0)
        (do
          (atom/set! timed-out 1)
          (printf "  ") (*test-pad-dots* test-name 97) (printf "  TIMEOUT\n")
          (atom/add! *main-failed* 1)
          (atom/sub! *main-pending* 1)
          (check-main-done))
        nil)})))

    (= {done-fn} (\ {passed} {
      (= {prev} (atom/get timed-out))
      (atom/set! timed-out 2)
      (if (!= prev 0)
        nil
        (do
          (aio/cancel timer-handle)
          (= {end-time} (time-us {}))
          (= {elapsed} (- end-time start-time))
          (if passed
            (do
              (printf "  ") (*test-pad-dots* test-name 97) (printf "  PASS : in %ld(us)\n" elapsed)
              (atom/add! *main-passed* 1))
            (do
              (printf "  ") (*test-pad-dots* test-name 97) (printf "  FAIL : in %ld(us)\n" elapsed)
              (atom/add! *main-failed* 1)))
          (atom/sub! *main-pending* 1)
          (check-main-done)))}))

    (aio/schedule aio 0 (\ {} (test-body done-fn)))
  })

  (fun {check-main-done} {
    (= {pending} (atom/get *main-pending*))
    (if (== pending 0)
      (do
        (printf "\n  Main tests done: %ld passed, %ld failed\n\n" 
                (atom/get *main-passed*) (atom/get *main-failed*))
        (aio/schedule aio 0 (\ {} (run-broadcaster-tests-sequentially))))
      nil)
  })

  (fun {run-broadcaster-tests-sequentially} {
    (printf "üß™ [%ld/%ld] Debug Handler Route Matching (broadcaster tests - sequential)\n" 
            (len broadcaster-tests) (len broadcaster-tests))
    (run-tests-sequentially aio broadcaster-tests (\ {passed failed} {
      (atom/set! *bc-passed* passed)
      (atom/set! *bc-failed* failed)
      (print-final-results-and-exit)
    }))
  })

  (fun {print-final-results-and-exit} {
    (= {total-passed} (+ (atom/get *main-passed*) (atom/get *bc-passed*)))
    (= {total-failed} (+ (atom/get *main-failed*) (atom/get *bc-failed*)))
    (printf "\nüèÅ Test Results: ")
    (if (== total-failed 0)
      (printf "All %ld tests passed!\n" total-passed)
      (printf "%ld passed, %ld failed\n" total-passed total-failed))
    (aio/stop aio)
    (shutdown (if (== total-failed 0) 0 1))
  })

  (map start-one-main-test main-tests)

  (aio/schedule aio 60000 (\ {} {
    (printf "\nSUITE TIMEOUT: tests still pending\n")
    (aio/stop aio)
    (shutdown 1)}))

  (aio/run aio)
})

(run-main-tests-then-broadcaster aio main-tests broadcaster-tests)
