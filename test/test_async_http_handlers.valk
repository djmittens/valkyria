; Async HTTP Handler Integration Tests
; Tests aio/sleep, aio/delay, and aio/then chains in real HTTP handlers
; to exercise async completion paths in aio_uv.c

(load "src/prelude.valk")

; Test state tracking
(def {tests-passed} 0)
(def {tests-failed} 0)
(def {tests-run} 0)

; Helper to check response and print result
(fun {check-response name resp expected-status expected-body} {
  (def {tests-run} (+ tests-run 1))
  (if (error? resp)
    {(do
       (def {tests-failed} (+ tests-failed 1))
       (printf "  ❌ %s: FAIL (error: %s)\n" name (str resp)))}
    {(do
       (= {status} (http2/response-status resp))
       (= {body} (http2/response-body resp))
       (if (and (== status expected-status) (== body expected-body))
         {(do
            (def {tests-passed} (+ tests-passed 1))
            (printf "  ✅ %s: PASS\n" name))}
         {(do
            (def {tests-failed} (+ tests-failed 1))
            (printf "  ❌ %s: FAIL (got status=%s body=%s)\n" name status body))}))})
})

; Test port
(def {TEST_PORT} 8471)

; Create AIO system
(def {aio} (aio/start))

; ============================================================================
; Handler 1: Uses aio/delay - schedules callback after delay
; ============================================================================
(def {delay-handler}
  (\ {req} {
    (aio/delay aio 10 (\ {} {{:status "200" :body "delayed-response"}}))
  }))

; ============================================================================
; Handler 2: Uses aio/sleep with aio/then chain
; ============================================================================
(def {sleep-handler}
  (\ {req} {
    (aio/then (aio/sleep 5) (\ {_} {{:status "200" :body "slept"}}))
  }))

; ============================================================================
; Handler 3: Uses aio/sleep with double aio/then chain
; ============================================================================
(def {sleep-chain-handler}
  (\ {req} {
    (aio/then 
      (aio/sleep 5)
      (\ {_} {
        (aio/then (aio/sleep 5) (\ {_} {{:status "200" :body "slept-twice"}}))
      }))
  }))

; ============================================================================
; Handler 4: Uses aio/catch for error recovery
; ============================================================================
(def {catch-handler}
  (\ {req} {
    (aio/catch (aio/fail "error") (\ {err} {{:status "200" :body "recovered"}}))
  }))

; ============================================================================
; Handler 5: Uses aio/finally - cleanup runs on success
; Note: aio/finally with synchronous completion has a known issue.
; We use aio/then after aio/finally to ensure async path is taken.
; ============================================================================
(def {finally-success-handler}
  (\ {req} {
    (aio/then
      (aio/finally
        (aio/sleep 5)
        (\ {} {nil}))
      (\ {_} {{:status "200" :body "with-finally"}}))
  }))

; ============================================================================
; Handler 6: Uses aio/finally - cleanup runs on failure (recovered by catch)
; ============================================================================
(def {finally-fail-handler}
  (\ {req} {
    (aio/catch
      (aio/finally
        (aio/fail "inner-error")
        (\ {} {nil}))
      (\ {err} {{:status "200" :body "finally-recovered"}}))
  }))

; ============================================================================
; Handler 7: Uses aio/all - wait for multiple sleeps in parallel
; ============================================================================
(def {all-handler}
  (\ {req} {
    (aio/then
      (aio/all (list (aio/sleep 5) (aio/sleep 10) (aio/sleep 15)))
      (\ {results} {{:status "200" :body "all-completed"}}))
  }))

; ============================================================================
; Handler 8: Uses aio/all with failure - fails fast
; ============================================================================
(def {all-fail-handler}
  (\ {req} {
    (aio/catch
      (aio/all (list (aio/sleep 100) (aio/fail "one-failed") (aio/sleep 100)))
      (\ {err} {{:status "200" :body "all-failed"}}))
  }))

; ============================================================================
; Handler 9: Uses aio/race - first to complete wins
; ============================================================================
(def {race-handler}
  (\ {req} {
    (aio/then
      (aio/race (list (aio/sleep 5) (aio/sleep 100) (aio/sleep 200)))
      (\ {result} {{:status "200" :body "race-won"}}))
  }))

; ============================================================================
; Handler 10: Uses aio/any - first success wins
; ============================================================================
(def {any-handler}
  (\ {req} {
    (aio/then
      (aio/any (list (aio/fail "e1") (aio/sleep 5) (aio/fail "e2")))
      (\ {result} {{:status "200" :body "any-success"}}))
  }))

; ============================================================================
; Handler 11: Uses aio/any with all failures
; ============================================================================
(def {any-all-fail-handler}
  (\ {req} {
    (aio/catch
      (aio/any (list (aio/fail "a") (aio/fail "b") (aio/fail "c")))
      (\ {err} {{:status "200" :body "any-all-failed"}}))
  }))

; ============================================================================
; Handler 12: Uses aio/let with single binding
; NOTE: aio/let requires QEXPR syntax {((var expr))} for bindings
; ============================================================================
(def {let-single-handler}
  (\ {req} {
    (aio/let {((x (aio/sleep 5)))} {:status "200" :body "let-single"})
  }))

; ============================================================================
; Handler 13: Uses aio/let with parallel bindings
; ============================================================================
(def {let-parallel-handler}
  (\ {req} {
    (aio/let {((a (aio/sleep 5)) (b (aio/sleep 10)))} {:status "200" :body "let-parallel"})
  }))

; ============================================================================
; Handler 14: Uses aio/let with :then barrier for sequential execution
; ============================================================================
(def {let-then-handler}
  (\ {req} {
    (aio/let {((x (aio/sleep 5)) :then (y (aio/sleep 5)))} {:status "200" :body "let-then"})
  }))

; ============================================================================
; Handler 15: Uses aio/do for sequential async operations
; ============================================================================
(def {do-handler}
  (\ {req} {
    (aio/do {
      (x <- (aio/sleep 5))
      (y <- (aio/sleep 5))
      {:status "200" :body "do-sequential"}})
  }))

; ============================================================================
; Handler 16: Uses aio/bracket for resource safety
; ============================================================================
(def {bracket-handler}
  (\ {req} {
    (aio/bracket
      (aio/then (aio/sleep 5) (\ {_} {"resource"}))
      (\ {r} {(aio/then (aio/sleep 5) (\ {_} {nil}))})
      (\ {r} {(aio/then (aio/sleep 5) (\ {_} {{:status "200" :body "bracket-used"}}))}))
  }))

; ============================================================================
; Handler 17: Uses aio/on-cancel (cancellation handler registered)
; ============================================================================
(def {on-cancel-handler}
  (\ {req} {
    (aio/then
      (aio/on-cancel
        (aio/sleep 5)
        (\ {} {nil}))
      (\ {_} {{:status "200" :body "on-cancel-done"}}))
  }))

; ============================================================================
; Handler 18: Triple nested aio/then chain
; ============================================================================
(def {triple-then-handler}
  (\ {req} {
    (aio/then (aio/sleep 5)
      (\ {_} {(aio/then (aio/sleep 5)
        (\ {_} {(aio/then (aio/sleep 5)
          (\ {_} {{:status "200" :body "triple-then"}}))}))}))
  }))

; ============================================================================
; Handler 19: aio/catch that re-throws (tests error propagation)
; Note: Use sleep to ensure async path is taken
; ============================================================================
(def {catch-rethrow-handler}
  (\ {req} {
    (aio/catch
      (aio/then
        (aio/sleep 5)
        (\ {_} {(aio/fail "original")}))
      (\ {err} {{:status "200" :body "catch-rethrow"}}))
  }))

; ============================================================================
; Handler 20: Complex combinator chain (all -> race)
; ============================================================================
(def {complex-chain-handler}
  (\ {req} {
    (aio/then
      (aio/all (list (aio/sleep 5) (aio/sleep 10)))
      (\ {results} {
        (aio/then
          (aio/race (list (aio/sleep 5) (aio/sleep 100)))
          (\ {r} {{:status "200" :body "complex-chain"}}))}))
  }))

; ============================================================================
; Handler 21: aio/let with multiple :then barriers (sequential groups)
; ============================================================================
(def {let-multi-then-handler}
  (\ {req} {
    (aio/let {((a (aio/sleep 5)) :then (b (aio/sleep 5)) :then (c (aio/sleep 5)))}
      {:status "200" :body "let-multi-then"})
  }))

; ============================================================================
; Handler 22: aio/pure - returns immediately with value
; ============================================================================
(def {pure-handler}
  (\ {req} {
    (aio/then (aio/pure "immediate-value") (\ {v} {{:status "200" :body "pure-ok"}}))
  }))

; ============================================================================
; Handler 23: aio/status - check handle status
; ============================================================================
(def {status-handler}
  (\ {req} {
    (= {h} (aio/sleep 5))
    (= {s} (aio/status h))
    (aio/then h (\ {_} {{:status "200" :body "status-ok"}}))
  }))

; ============================================================================
; Handler 24: aio/all with mixed handles (sleep + pure)
; ============================================================================
(def {all-mixed-handler}
  (\ {req} {
    (aio/then
      (aio/all (list (aio/sleep 5) (aio/pure "v1") (aio/sleep 5)))
      (\ {results} {{:status "200" :body "all-mixed-ok"}}))
  }))

; ============================================================================
; Handler 25: aio/race with immediate fail (first handle fails immediately)
; ============================================================================
(def {race-immediate-fail-handler}
  (\ {req} {
    (aio/catch
      (aio/race (list (aio/fail "fast-fail") (aio/sleep 100)))
      (\ {err} {{:status "200" :body "race-fail-caught"}}))
  }))

; ============================================================================
; Handler 26: aio/race with pure (immediate result)
; ============================================================================
(def {race-pure-handler}
  (\ {req} {
    (aio/then
      (aio/race (list (aio/pure "fast") (aio/sleep 100)))
      (\ {_} {{:status "200" :body "race-pure-ok"}}))
  }))

; ============================================================================
; Handler 27: aio/any with pure (immediate success)
; ============================================================================
(def {any-pure-handler}
  (\ {req} {
    (aio/then
      (aio/any (list (aio/fail "e") (aio/pure "fast") (aio/fail "e2")))
      (\ {_} {{:status "200" :body "any-pure-ok"}}))
  }))

; ============================================================================
; Handler 28: Deep chain of aio/catch (error recovery chain)
; ============================================================================
(def {catch-chain-handler}
  (\ {req} {
    (aio/catch
      (aio/then (aio/sleep 5) (\ {_} {(aio/fail "error1")}))
      (\ {e} {{:status "200" :body "catch-chain-ok"}}))
  }))

; ============================================================================
; Handler 29: aio/all with empty list
; ============================================================================
(def {all-empty-handler}
  (\ {req} {
    (aio/then
      (aio/all (list))
      (\ {results} {{:status "200" :body "all-empty-ok"}}))
  }))

; ============================================================================
; Handler 30: aio/race with single element
; ============================================================================
(def {race-single-handler}
  (\ {req} {
    (aio/then
      (aio/race (list (aio/sleep 5)))
      (\ {result} {{:status "200" :body "race-single-ok"}}))
  }))

; ============================================================================
; Handler 31: aio/any with single element
; ============================================================================
(def {any-single-handler}
  (\ {req} {
    (aio/then
      (aio/any (list (aio/sleep 5)))
      (\ {result} {{:status "200" :body "any-single-ok"}}))
  }))

; ============================================================================
; Handler 32: aio/let with many parallel bindings (tests capacity growth)
; ============================================================================
(def {let-many-handler}
  (\ {req} {
    (aio/let {((a (aio/sleep 5)) (b (aio/sleep 5)) (c (aio/sleep 5))
               (d (aio/sleep 5)) (e (aio/sleep 5)) (f (aio/sleep 5)))}
      {:status "200" :body "let-many-ok"})
  }))

; ============================================================================
; Handler 33: aio/do with result
; ============================================================================
(def {do-result-handler}
  (\ {req} {
    (aio/do {
      (x <- (aio/sleep 5))
      (y <- (aio/sleep 5))
      {:status "200" :body "do-result-ok"}})
  }))

; ============================================================================
; Handler 34: aio/bracket with error in use phase
; ============================================================================
(def {bracket-error-handler}
  (\ {req} {
    (aio/catch
      (aio/bracket
        (aio/then (aio/sleep 5) (\ {_} {"resource"}))
        (\ {r} {(aio/then (aio/sleep 5) (\ {_} {nil}))})
        (\ {r} {(aio/fail "use-phase-error")}))
      (\ {err} {{:status "200" :body "bracket-error-ok"}}))
  }))

; ============================================================================
; Handler 35: aio/on-cancel with completion (doesn't actually cancel)
; ============================================================================
(def {on-cancel-complete-handler}
  (\ {req} {
    (aio/then
      (aio/on-cancel
        (aio/then (aio/sleep 5) (\ {_} {"value"}))
        (\ {} {nil}))
      (\ {_} {{:status "200" :body "on-cancel-complete-ok"}}))
  }))

; ============================================================================
; Handler 36: aio/any with sync failures is already covered by any-all-fail-handler
; Async failure propagation in aio/any has a separate issue to investigate
; ============================================================================

; ============================================================================
; Handler 37: aio/scope with sync completion
; ============================================================================
(def {scope-sync-handler}
  (\ {req} {
    (aio/then
      (aio/scope (\ {s} {(aio/pure "sync-result")}))
      (\ {r} {{:status "200" :body "scope-sync-ok"}}))
  }))

; ============================================================================
; Handler 38: aio/scope with async completion
; ============================================================================
(def {scope-async-handler}
  (\ {req} {
    (aio/then
      (aio/scope (\ {s} {(aio/sleep 5)}))
      (\ {r} {{:status "200" :body "scope-async-ok"}}))
  }))

; ============================================================================
; Handler 39: aio/scope with error return
; ============================================================================
(def {scope-error-handler}
  (\ {req} {
    (aio/catch
      (aio/scope (\ {s} {(error "scope-error")}))
      (\ {err} {{:status "200" :body "scope-error-ok"}}))
  }))

; ============================================================================
; Handler 40: aio/any with all async failures (exercises valk_async_any_child_failed)
; Uses aio/then + aio/sleep + aio/fail to create async failures
; ============================================================================
(def {any-async-fail-handler}
  (\ {req} {
    (aio/catch
      (aio/any (list
        (aio/then (aio/sleep 5) (\ {_} {(aio/fail "async-fail-1")}))
        (aio/then (aio/sleep 10) (\ {_} {(aio/fail "async-fail-2")}))
        (aio/then (aio/sleep 15) (\ {_} {(aio/fail "async-fail-3")}))))
      (\ {err} {{:status "200" :body "any-async-fail-ok"}}))
  }))

; ============================================================================
; Handler 41: Direct async failure - handler returns failed handle after sleep
; Exercises VALK_ASYNC_FAILED path in frame callback (lines 2443-2452)
; ============================================================================
(def {async-fail-handler}
  (\ {req} {
    (aio/then (aio/sleep 5) (\ {_} {(aio/fail "handler-async-failed")}))
  }))

; ============================================================================
; Handler 42: aio/all with async failures (one fails after delay)
; ============================================================================
(def {all-async-fail-handler}
  (\ {req} {
    (aio/catch
      (aio/all (list
        (aio/sleep 5)
        (aio/then (aio/sleep 10) (\ {_} {(aio/fail "all-async-fail")}))
        (aio/sleep 15)))
      (\ {err} {{:status "200" :body "all-async-fail-ok"}}))
  }))

; ============================================================================
; Handler 43: aio/race with async failure wins
; ============================================================================
(def {race-async-fail-handler}
  (\ {req} {
    (aio/catch
      (aio/race (list
        (aio/then (aio/sleep 5) (\ {_} {(aio/fail "race-async-fail")}))
        (aio/sleep 100)))
      (\ {err} {{:status "200" :body "race-async-fail-ok"}}))
  }))

; ============================================================================
; Handler 44: Deep nesting of aio/then chains (stress test propagation)
; ============================================================================
(def {deep-chain-handler}
  (\ {req} {
    (aio/then (aio/sleep 5) (\ {_} {
      (aio/then (aio/sleep 5) (\ {_} {
        (aio/then (aio/sleep 5) (\ {_} {
          (aio/then (aio/sleep 5) (\ {_} {
            (aio/then (aio/sleep 5) (\ {_} {
              {:status "200" :body "deep-chain-ok"}
            }))
          }))
        }))
      }))
    }))
  }))

; ============================================================================
; Handler 45: aio/scope with async failure inside
; ============================================================================
(def {scope-async-fail-handler}
  (\ {req} {
    (aio/catch
      (aio/scope (\ {s} {
        (aio/then (aio/sleep 5) (\ {_} {(aio/fail "scope-inner-fail")}))
      }))
      (\ {err} {{:status "200" :body "scope-async-fail-ok"}}))
  }))

; ============================================================================
; Handler 46: Immediate failure - handler returns already-failed handle
; This tests the VALK_ASYNC_FAILED path in on_frame_recv_callback
; ============================================================================
(def {immediate-fail-handler}
  (\ {req} {
    (aio/fail "immediate-handler-failure")
  }))

; ============================================================================
; Handler 47: Immediate completion - handler returns already-completed handle
; This tests the VALK_ASYNC_COMPLETED path with immediate result
; ============================================================================
(def {immediate-complete-handler}
  (\ {req} {
    (aio/pure {:status "200" :body "immediate-complete-ok"})
  }))

; ============================================================================
; Handler 48: on-cancel callback with race cancellation
; Tests that on_cancel is called when a handle loses a race
; This exercises the standalone async arena acquisition path in valk_async_handle_cancel
; ============================================================================
(def {race-cancel-handler}
  (\ {req} {
    (aio/then
      (aio/race (list
        (aio/sleep 5)
        (aio/on-cancel
          (aio/sleep 1000)
          (\ {} {(println "on-cancel callback invoked!")}))))
      (\ {result} {
        {:status "200" :body "race-cancel-ok"}
      }))
  }))

; ============================================================================
; Handler 49: Multiple on-cancel callbacks with race
; Tests multiple losers getting their on_cancel called
; ============================================================================
(def {nested-cancel-handler}
  (\ {req} {
    (aio/then
      (aio/race (list
        (aio/sleep 5)
        (aio/on-cancel (aio/sleep 1000) (\ {} {(println "cancel1")}))
        (aio/on-cancel (aio/sleep 1000) (\ {} {(println "cancel2")}))))
      (\ {result} {
        {:status "200" :body "nested-cancel-ok"}
      }))
  }))

; ============================================================================
; Router helper
; ============================================================================
(fun {route path handlers} {
  (if (nil? handlers)
    {{:status "404" :body "not-found"}}
    {(if (== path (fst (fst handlers)))
      {(eval (snd (fst handlers)))}
      {(route path (tail handlers))})})
})

; ============================================================================
; Router
; ============================================================================
(def {router}
  (\ {req} {
    (= {path} (plist/get req (head {:path})))
    (route path (list
      {"/delay" {(delay-handler req)}}
      {"/sleep" {(sleep-handler req)}}
      {"/sleep-chain" {(sleep-chain-handler req)}}
      {"/catch" {(catch-handler req)}}
      {"/finally-success" {(finally-success-handler req)}}
      {"/finally-fail" {(finally-fail-handler req)}}
      {"/all" {(all-handler req)}}
      {"/all-fail" {(all-fail-handler req)}}
      {"/race" {(race-handler req)}}
      {"/any" {(any-handler req)}}
      {"/any-all-fail" {(any-all-fail-handler req)}}
      {"/let-single" {(let-single-handler req)}}
      {"/let-parallel" {(let-parallel-handler req)}}
      {"/let-then" {(let-then-handler req)}}
      {"/do" {(do-handler req)}}
      {"/bracket" {(bracket-handler req)}}
      {"/on-cancel" {(on-cancel-handler req)}}
      {"/triple-then" {(triple-then-handler req)}}
      {"/catch-rethrow" {(catch-rethrow-handler req)}}
      {"/complex-chain" {(complex-chain-handler req)}}
      {"/let-multi-then" {(let-multi-then-handler req)}}
      {"/pure" {(pure-handler req)}}
      {"/status" {(status-handler req)}}
      {"/all-mixed" {(all-mixed-handler req)}}
      {"/race-immediate-fail" {(race-immediate-fail-handler req)}}
      {"/race-pure" {(race-pure-handler req)}}
      {"/any-pure" {(any-pure-handler req)}}
      {"/catch-chain" {(catch-chain-handler req)}}
      {"/all-empty" {(all-empty-handler req)}}
      {"/race-single" {(race-single-handler req)}}
      {"/any-single" {(any-single-handler req)}}
      {"/let-many" {(let-many-handler req)}}
      {"/do-result" {(do-result-handler req)}}
      {"/bracket-error" {(bracket-error-handler req)}}
      {"/on-cancel-complete" {(on-cancel-complete-handler req)}}
      {"/scope-sync" {(scope-sync-handler req)}}
      {"/scope-async" {(scope-async-handler req)}}
      {"/scope-error" {(scope-error-handler req)}}
      {"/any-async-fail" {(any-async-fail-handler req)}}
      {"/async-fail" {(async-fail-handler req)}}
      {"/all-async-fail" {(all-async-fail-handler req)}}
      {"/race-async-fail" {(race-async-fail-handler req)}}
      {"/deep-chain" {(deep-chain-handler req)}}
      {"/scope-async-fail" {(scope-async-fail-handler req)}}
      {"/immediate-fail" {(immediate-fail-handler req)}}
      {"/immediate-complete" {(immediate-complete-handler req)}}
      {"/race-cancel" {(race-cancel-handler req)}}
      {"/nested-cancel" {(nested-cancel-handler req)}}))
  }))

; Final cleanup function
(fun {finish-tests} {
  (println "")
  (printf "=== Results: %d/%d tests passed ===\n" tests-passed tests-run)
  (if (== tests-failed 0)
    {(println "PASS: All async handler tests passed!")}
    {(printf "FAIL: %d tests failed\n" tests-failed)})
  (aio/stop aio)
})

; Test runner - chains requests via continuation
(fun {test-request path name expected-body next-fn} {
  (http2/client-request aio "127.0.0.1" TEST_PORT path
    (\ {resp} {
      (check-response name resp "200" expected-body)
      (next-fn)
    }))
})

; Test runner for 500 responses (error cases)
(fun {test-error-request path name expected-body next-fn} {
  (http2/client-request aio "127.0.0.1" TEST_PORT path
    (\ {resp} {
      (check-response name resp "500" expected-body)
      (next-fn)
    }))
})

; Start server
(println "")
(println "=== Async HTTP Handler Integration Tests ===")
(println "")
(printf "Starting test server on port %d...\n" TEST_PORT)
(http2/server-listen aio TEST_PORT router)

; Run tests after server starts
(aio/schedule aio 200 (\ {} {
  (println "Running tests...")
  (println "")

  (test-request "/delay" "aio/delay" "delayed-response" (\ {} {
  (test-request "/sleep" "aio/sleep" "slept" (\ {} {
  (test-request "/sleep-chain" "aio/sleep chain" "slept-twice" (\ {} {
  (test-request "/catch" "aio/catch" "recovered" (\ {} {
  (test-request "/finally-success" "aio/finally success" "with-finally" (\ {} {
  (test-request "/finally-fail" "aio/finally fail" "finally-recovered" (\ {} {
  (test-request "/all" "aio/all parallel" "all-completed" (\ {} {
  (test-request "/all-fail" "aio/all fail-fast" "all-failed" (\ {} {
  (test-request "/race" "aio/race" "race-won" (\ {} {
  (test-request "/any" "aio/any success" "any-success" (\ {} {
  (test-request "/any-all-fail" "aio/any all-fail" "any-all-failed" (\ {} {
  (test-request "/let-single" "aio/let single" "let-single" (\ {} {
  (test-request "/let-parallel" "aio/let parallel" "let-parallel" (\ {} {
  (test-request "/let-then" "aio/let :then barrier" "let-then" (\ {} {
  (test-request "/do" "aio/do sequential" "do-sequential" (\ {} {
  (test-request "/bracket" "aio/bracket" "bracket-used" (\ {} {
  (test-request "/on-cancel" "aio/on-cancel" "on-cancel-done" (\ {} {
  (test-request "/triple-then" "triple aio/then" "triple-then" (\ {} {
  (test-request "/catch-rethrow" "aio/catch rethrow" "catch-rethrow" (\ {} {
  (test-request "/complex-chain" "complex combinator" "complex-chain" (\ {} {
  (test-request "/let-multi-then" "aio/let multi :then" "let-multi-then" (\ {} {
  (test-request "/pure" "aio/pure" "pure-ok" (\ {} {
  (test-request "/status" "aio/status" "status-ok" (\ {} {
  (test-request "/all-mixed" "aio/all mixed" "all-mixed-ok" (\ {} {
  (test-request "/race-immediate-fail" "aio/race immediate fail" "race-fail-caught" (\ {} {
  (test-request "/race-pure" "aio/race pure" "race-pure-ok" (\ {} {
  (test-request "/any-pure" "aio/any pure" "any-pure-ok" (\ {} {
  (test-request "/catch-chain" "aio/catch chain" "catch-chain-ok" (\ {} {
  (test-request "/all-empty" "aio/all empty" "all-empty-ok" (\ {} {
  (test-request "/race-single" "aio/race single" "race-single-ok" (\ {} {
  (test-request "/any-single" "aio/any single" "any-single-ok" (\ {} {
  (test-request "/let-many" "aio/let many bindings" "let-many-ok" (\ {} {
  (test-request "/do-result" "aio/do result" "do-result-ok" (\ {} {
  (test-request "/bracket-error" "aio/bracket error" "bracket-error-ok" (\ {} {
  (test-request "/on-cancel-complete" "aio/on-cancel complete" "on-cancel-complete-ok" (\ {} {
  (test-request "/scope-sync" "aio/scope sync" "scope-sync-ok" (\ {} {
  (test-request "/scope-async" "aio/scope async" "scope-async-ok" (\ {} {
  (test-request "/scope-error" "aio/scope error" "scope-error-ok" (\ {} {
  (test-request "/any-async-fail" "aio/any async all-fail" "any-async-fail-ok" (\ {} {
  (test-request "/all-async-fail" "aio/all async fail" "all-async-fail-ok" (\ {} {
  (test-request "/race-async-fail" "aio/race async fail" "race-async-fail-ok" (\ {} {
  (test-request "/deep-chain" "deep aio/then chain" "deep-chain-ok" (\ {} {
  (test-request "/scope-async-fail" "aio/scope async fail" "scope-async-fail-ok" (\ {} {
  (test-request "/immediate-complete" "immediate aio/pure" "immediate-complete-ok" (\ {} {
  (test-error-request "/immediate-fail" "immediate aio/fail" "Async operation failed" (\ {} {
  (test-request "/race-cancel" "on-cancel via race" "race-cancel-ok" (\ {} {
  (test-request "/nested-cancel" "nested on-cancel" "nested-cancel-ok" (\ {} {
    (finish-tests)
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
  }))
}))

; Timeout
(aio/schedule aio 30000 (\ {} {
  (println "TIMEOUT!")
  (aio/stop aio)
}))

(aio/run aio)
(if (== tests-failed 0) {(exit 0)} {(exit 1)})
