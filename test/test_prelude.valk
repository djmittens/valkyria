; Standard Library Tests - migrated from test_std.c
; Run with: ./build/valk test/test_prelude.valk

; Load prelude first (has all the standard functions)
(load "src/prelude.valk")

; Load test framework
(load "src/modules/test.valk")

; Set the test suite name

; Test: fun macro creates callable functions

; Test: curry (unpack) transforms function to take list

; Test: uncurry (pack) transforms function to take varargs

; Test: do executes multiple expressions, returns last

; Test: let creates new scope

; Test: nth accesses list elements (1-indexed!)

; Test: split divides list at index

; Test: map applies function to each element

; Test: logical not

; Test: fst, snd, trd accessors

; Test: last accessor

; Test: take n elements from list

; Test: drop n elements from list

; Test: exists checks if element in list

; Test: filter keeps elements matching predicate

; Test: foldl reduces list

; Test: sum and product convenience functions

; Test: logical operators

; Test: flip swaps function arguments

; Test: select (switch/case with conditions)

; Test: case (switch on specific value)

; ============================================================================
; Regression tests for environment scoping and varargs
; ============================================================================

; Test: select with dynamic scoping - accessing caller's local variables
; Uses hybrid scoping: lexical (parent chain) with dynamic fallback

; Test: varargs bind to empty when only required args provided

; ============================================================================
; Builtin function tests
; ============================================================================

; Test: eval evaluates quoted expressions

; Test: head returns first element directly

; Test: tail returns rest of list

; Test: head and tail composition

; Test: join concatenates lists

; Test: list creates a qexpr from arguments

; Test: len returns list length

; ============================================================================
; String operation tests
; ============================================================================

; Test: string comparison

; Test: strings in lists

; ============================================================================
; List reverse tests
; ============================================================================

; ============================================================================
; Property list (plist) tests
; ============================================================================

; Run all tests
(test/run (list
  (test "prelude-fun-definition"
    {do
    (fun {add a b} {+ a b})
    (test/assert-eq 110 (add 10 100) "defined function should be callable")

    ; Test that calling undefined symbol in function body errors correctly
    (fun {bad-fn a b} {+ a undefined})
    ; Note: We can't easily test error cases yet without try/catch
    true
  })
  (test "prelude-curry"
    {test/assert-eq 6 ((curry +) {1 2 3}) "curry should unpack list to args"})
  (test "prelude-uncurry"
    {test/assert-eq 6 ((uncurry (curry +)) 1 2 3)
    "uncurry should pack varargs to list"})
  (test "prelude-do"
    {do
    (= {a} 2)
    (test/assert-eq 3 (do (= {a} 2) (+ 1 2 3) (+ 1 a))
      "do should return last expression")})
  (test "prelude-let"
    {do
    ; do leaks scope
    (do (= {a} 2) (+ 1 2 3) (+ 1 a))
    (test/assert-eq 2 a "do should leak scope")

    ; let does not leak scope
    (let {do (= {b} 99) (+ 1 2 3) (+ 1 b)})
    ; b should not exist in outer scope
    ; Note: Can't test error cases easily yet
    true
  })
  (test "prelude-nth"
    {do
    (test/assert-eq 1 (nth 1 {1 2 3}) "nth 1 should return first element")
    (test/assert-eq 40 (nth 4 {99 2 3 40 5 6}) "nth 4 should return 4th element")
    ; nth 0 should error - can't test yet
    true
  })
  (test "prelude-split"
    {do
    (= {result} (split 3 {1 2 3 4 5 6 7 8}))
    (test/assert-eq 2 (len result) "split should return 2 lists")
    (test/assert-eq 3 (len (nth 1 result)) "left side should have 3 elements")
    (test/assert-eq 5 (len (nth 2 result)) "right side should have 5 elements")

    ; Edge case: split at 0
    (= {result2} (split 0 {1 2 3 4 5 6 7 8}))
    (test/assert-eq 2 (len result2) "split 0 should still return 2 lists")})
  (test "prelude-map"
    {test/assert
    (== (map (\ {x} {* 2 x}) {1 2 3}) {2 4 6})
    "map should double each element"})
  (test "prelude-not"
    {do
    (test/assert-eq 0 (not true) "not true should be false (0)")
    (test/assert-eq 1 (not false) "not false should be true (1)")})
  (test "prelude-list-accessors"
    {do
    (test/assert-eq 1 (fst {1 2 3}) "fst should return first element")
    (test/assert-eq 2 (snd {1 2 3}) "snd should return second element")
    (test/assert-eq 3 (trd {1 2 3}) "trd should return third element")})
  (test "prelude-last"
    {test/assert-eq 5 (last {1 2 3 4 5}) "last should return final element"})
  (test "prelude-take"
    {do
    (= {result} (take 3 {1 2 3 4 5}))
    (test/assert-eq 3 (len result) "take 3 should return 3 elements")
    (test/assert-eq 1 (nth 1 result) "first element should be 1")
    (test/assert-eq 3 (nth 3 result) "third element should be 3")})
  (test "prelude-drop"
    {do
    (= {result} (drop 2 {1 2 3 4 5}))
    (test/assert-eq 3 (len result) "drop 2 should leave 3 elements")
    (test/assert-eq 3 (nth 1 result) "first element should now be 3")})
  (test "prelude-exists"
    {do
    (test/assert-eq 1 (exists 3 {1 2 3 4 5}) "3 should exist in list")
    (test/assert-eq 0 (exists 99 {1 2 3 4 5}) "99 should not exist in list")
    (test/assert-eq 0 (exists 1 {}) "nothing exists in empty list")})
  (test "prelude-filter"
    {do
    (= {result} (filter (\ {x} {> x 2}) {1 2 3 4 5}))
    (test/assert-eq 3 (len result) "should keep 3 elements > 2")
    (test/assert-eq 3 (nth 1 result) "first filtered element should be 3")})
  (test "prelude-foldl"
    {do
    (test/assert-eq 15 (foldl + 0 {1 2 3 4 5}) "foldl + should sum to 15")
    (test/assert-eq 120 (foldl * 1 {1 2 3 4 5}) "foldl * should multiply to 120")})
  (test "prelude-sum-product"
    {do
    (test/assert-eq 15 (sum {1 2 3 4 5}) "sum should add all elements")
    (test/assert-eq 120 (product {1 2 3 4 5}) "product should multiply all")})
  (test "prelude-logic"
    {do
    (test/assert-eq 1 (and 1 1) "and 1 1 should be 1")
    (test/assert-eq 0 (and 1 0) "and 1 0 should be 0")
    (test/assert-eq 0 (and 0 1) "and 0 1 should be 0")

    (test/assert-eq 1 (or 1 0) "or 1 0 should be 1")
    (test/assert-eq 1 (or 0 1) "or 0 1 should be 1")
    (test/assert-eq 0 (or 0 0) "or 0 0 should be 0")})
  (test "prelude-flip"
    {do
    (fun {div a b} {/ a b})
    (test/assert-eq 2 (div 10 5) "10 / 5 should be 2")
    (test/assert-eq 0 (flip div 10 2) "flip should swap: (div 2 10) = 2 / 10 = 0")})
  (test "prelude-select"
    {do
    (= {result} (select
      {(== 1 2) "bad"}
      {(== 2 3) "also bad"}
      {otherwise "good"}))
    (test/assert-eq "good" result "select should match otherwise clause")})
  (test "prelude-case"
    {do
    (= {result} (case 2
      {{1} "one"}
      {{2} "two"}
      {{3} "three"}))
    (test/assert-eq "two" result "case should match value 2")})
  (test "select-dynamic-scoping"
    {do
    (fun {my-test n} {select {(== n 1) 100} {otherwise 999}})
    (test/assert-eq 100 (my-test 1) "select should access lambda parameter n")
    (test/assert-eq 999 (my-test 2) "select otherwise should work")})
  (test "varargs-with-required"
    {do
    (fun {test-fn a & as} {list a as})
    (= {result} (test-fn 42))
    (test/assert-eq 2 (len result) "result should have 2 elements")
    (test/assert-eq 42 (nth 1 result) "first element should be 42")
    (test/assert-eq 0 (len (nth 2 result)) "varargs should be empty list")

    ; Test with actual varargs
    (= {result2} (test-fn 1 2 3))
    (test/assert-eq 2 (len (nth 2 result2)) "varargs should have 2 elements")})
  (test "builtin-eval"
    {do
    (test/assert-eq 6 (eval {+ 1 2 3}) "eval should evaluate arithmetic")
    (test/assert-eq 42 (eval {* 6 7}) "eval should evaluate multiplication")

    ; Test eval with stored expression
    (= {expr} {+ 10 20})
    (test/assert-eq 30 (eval expr) "eval should work with stored expressions")

    ; Test nested eval
    (test/assert-eq 100 (eval {eval {* 10 10}}) "nested eval should work")
    true
  })
  (test "builtin-head"
    {do
    (test/assert-eq 1 (head {1 2 3}) "head extracts first element")
    (test/assert-eq 42 (head {42}) "head of single element")
    (test/assert-eq 1 (fst {1 2 3}) "fst also extracts first element")
    true
  })
  (test "builtin-tail"
    {do
    (test/assert-eq 2 (len (tail {1 2 3})) "tail of 3 elements has 2")
    (test/assert-eq 0 (len (tail {1})) "tail of single element is empty")
    (test/assert-eq 2 (fst (tail {1 2 3})) "first of tail is second element")
    true
  })
  (test "builtin-head-tail-composition"
    {do
    (= {lst} {1 2 3 4 5})
    (test/assert-eq 2 (head (tail lst)) "head of tail gives second element")
    (test/assert-eq 3 (head (tail (tail lst))) "head of tail of tail gives third")
    (test/assert-eq 2 (len (tail (tail (tail lst)))) "triple tail leaves 2 elements")
    true
  })
  (test "builtin-join"
    {do
    (test/assert-eq 4 (len (join {1 2} {3 4})) "join two lists has 4 elements")
    (test/assert-eq 2 (len (join {} {1 2})) "join empty with list")
    (test/assert-eq 3 (len (join {1} {2} {3})) "join multiple lists")
    (test/assert-eq 4 (fst (tail (tail (tail (join {1 2} {3 4}))))) "fourth element is 4")
    true
  })
  (test "builtin-list"
    {do
    (test/assert-eq 3 (len (list 1 2 3)) "list creates 3-element qexpr")
    (test/assert-eq 0 (len (list)) "empty list")
    (test/assert-eq 1 (len (list 42)) "single element list")
    (test/assert-eq 42 (fst (list 42)) "list element accessible")
    true
  })
  (test "builtin-len"
    {do
    (test/assert-eq 0 (len {}) "empty list has length 0")
    (test/assert-eq 1 (len {a}) "single element has length 1")
    (test/assert-eq 5 (len {1 2 3 4 5}) "five elements has length 5")
    true
  })
  (test "string-comparison"
    {do
    (test/assert (== "hello" "hello") "equal strings")
    (test/assert (not (== "hello" "world")) "unequal strings")
    (test/assert (== "" "") "empty strings equal")
    true
  })
  (test "strings-in-lists"
    {do
    (= {strs} {"apple" "banana" "cherry"})
    (test/assert-eq 3 (len strs) "list of strings has correct length")
    (test/assert-eq "apple" (fst strs) "fst returns first string")
    (test/assert-eq "banana" (snd strs) "snd returns second string")
    true
  })
  (test "prelude-reverse"
    {do
    (test/assert (== (reverse {1 2 3}) {3 2 1}) "reverse should reverse 3 elements")
    (test/assert (== (reverse {1}) {1}) "reverse single element")
    (test/assert (== (reverse {}) {}) "reverse empty list")
    (test/assert (== (reverse {5 4 3 2 1}) {1 2 3 4 5}) "reverse 5 elements")
    true
  })
  (test "prelude-plist-get"
    {do
    (= {pl} {:name "Alice" :age 30 :city "NYC"})
    (test/assert-eq "Alice" (plist/get pl :name) "plist/get should find name")
    (test/assert-eq 30 (plist/get pl :age) "plist/get should find age")
    (test/assert-eq "NYC" (plist/get pl :city) "plist/get should find city")
    (test/assert-eq nil (plist/get pl :unknown) "plist/get should return nil for missing")
    (test/assert-eq nil (plist/get {} :any) "plist/get on empty returns nil")
    true
  })
  (test "prelude-plist-set"
    {do
    (= {pl} {:name "Alice"})
    (= {pl2} (plist/set pl :age 25))
    (test/assert-eq "Alice" (plist/get pl2 :name) "plist/set preserves existing")
    (test/assert-eq 25 (plist/get pl2 :age) "plist/set adds new key")
    
    ; Update existing key
    (= {pl3} (plist/set pl2 :name "Bob"))
    (test/assert-eq "Bob" (plist/get pl3 :name) "plist/set updates existing")
    (test/assert-eq 25 (plist/get pl3 :age) "plist/set preserves other keys")
    
    ; Set on empty plist
    (= {pl4} (plist/set {} :key "val"))
    (test/assert-eq "val" (plist/get pl4 :key) "plist/set on empty creates plist")
    true
  })
  (test "prelude-plist-has"
    {do
    (= {pl} {:name "Alice" :age 30})
    (test/assert-eq true (plist/has? pl :name) "plist/has? finds existing key")
    (test/assert-eq true (plist/has? pl :age) "plist/has? finds second key")
    (test/assert-eq false (plist/has? pl :missing) "plist/has? returns false for missing")
    (test/assert-eq false (plist/has? {} :any) "plist/has? on empty is false")
    true
  })
  (test "prelude-plist-keys"
    {do
    (= {pl} {:a 1 :b 2 :c 3})
    (= {keys} (plist/keys pl))
    (test/assert-eq 3 (len keys) "plist/keys returns all keys")
    (test/assert-eq :a (nth 1 keys) "first key is :a")
    (test/assert-eq :b (nth 2 keys) "second key is :b")
    (test/assert-eq :c (nth 3 keys) "third key is :c")
    (test/assert (== (plist/keys {}) nil) "plist/keys of empty is nil")
    true
  })
  (test "prelude-plist-vals"
    {do
    (= {pl} {:a 1 :b 2 :c 3})
    (= {vals} (plist/vals pl))
    (test/assert-eq 3 (len vals) "plist/vals returns all values")
    (test/assert-eq 1 (nth 1 vals) "first value is 1")
    (test/assert-eq 2 (nth 2 vals) "second value is 2")
    (test/assert-eq 3 (nth 3 vals) "third value is 3")
    (test/assert (== (plist/vals {}) nil) "plist/vals of empty is nil")
    true
  }))
  {:suite-name "Prelude Tests"})
