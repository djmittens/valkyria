; Test suite for aio/retry combinator
; Tests: aio/retry retries async operations with backoff

(load "src/prelude.valk")
(load "src/modules/test.valk")

(test/run (list
  (test "aio/retry returns a handle"
    {do
    (= {sys} (aio/await (aio/start)))
    (= {h} (aio/retry sys
      (\ {} {(aio/pure 42)})
      {:max-attempts 3 :backoff :exponential :base-ms 10}))
    (aio/await (aio/stop sys))
    (not (== h nil))
    })
  (test "aio/retry with exponential backoff"
    {do
    (= {sys} (aio/await (aio/start)))
    (= {h} (aio/retry sys
      (\ {} {(aio/pure 1)})
      {:max-attempts 3 :backoff :exponential :base-ms 5}))
    (aio/await (aio/stop sys))
    (= {status} (aio/status h))
    (not (== status nil))
    })
  (test "aio/retry with linear backoff"
    {do
    (= {sys} (aio/await (aio/start)))
    (= {h} (aio/retry sys
      (\ {} {(aio/pure 1)})
      {:max-attempts 3 :backoff :linear :base-ms 5}))
    (aio/await (aio/stop sys))
    (= {status} (aio/status h))
    (not (== status nil))
    })
  (test "aio/retry with no backoff"
    {do
    (= {sys} (aio/await (aio/start)))
    (= {h} (aio/retry sys
      (\ {} {(aio/pure 1)})
      {:max-attempts 3 :backoff :none :base-ms 5}))
    (aio/await (aio/stop sys))
    (= {status} (aio/status h))
    (not (== status nil))
    })
  (test "aio/retry with wrong arg count returns error"
    {do
    (= {result} (aio/retry))
    (error? result)
    })
  (test "aio/retry with non-function second arg returns error"
    {do
    (= {sys} (aio/await (aio/start)))
    (= {result} (aio/retry sys 42 {:max-attempts 1}))
    (aio/await (aio/stop sys))
    (error? result)
    })
  (test "aio/retry with non-qexpr third arg returns error"
    {do
    (= {sys} (aio/await (aio/start)))
    (= {result} (aio/retry sys (\ {} {(aio/pure 1)}) 42))
    (aio/await (aio/stop sys))
    (error? result)
    }))
  {:suite-name "aio/retry Tests"})
