; HTTP Integration Tests
; Tests http_api.valk functions that require real HTTP response objects
; Uses http2/mock-response builtin to create test responses

(load "src/prelude.valk")
(load "src/modules/test.valk")

; Define reverse - required by async_monadic.valk but not in prelude
(fun {reverse l} {
  (fun {reverse-helper acc remaining} {
    (if (== remaining nil)
      {acc}
      {(reverse-helper (join (list (head remaining)) acc) (tail remaining))})
  })
  (reverse-helper nil l)
})

(load "src/http_api.valk")

; ============================================================================
; Response Handler Tests - these cover the http2/response-ok? function
; ============================================================================

; ============================================================================
; Response Body Tests - these verify we can read response bodies
; ============================================================================

; ============================================================================
; Response Headers Tests
; ============================================================================

; ============================================================================
; Response Pipeline Tests - http2/log-response
; ============================================================================

; ============================================================================
; Response Pipeline Tests - http2/validate-status
; ============================================================================

; Test that validate-status returns error on mismatch (bug #3 fixed)
; Call error? directly on the result without assigning to avoid error propagation

; ============================================================================
; Async Pattern Tests - using mock responses via async/pure
; ============================================================================

; Test async patterns that use response objects

; ============================================================================
; Complex Workflow Tests
; ============================================================================

; ============================================================================
; Edge Cases
; ============================================================================

; ============================================================================
; Additional validate-status tests
; ============================================================================

; ============================================================================
; Async tests
; ============================================================================

; Mock fetch for testing
(fun {mock-fetch url} {
  (async/pure (http2/mock-response "200" (str "Response from: " url)))
})

; Test async/map-list with pure values - FIXED: calling convention bug

; ============================================================================
; Test http_api.valk functions - Now work after async calling convention fix
; ============================================================================
; NOTE: The GC crash issue (BUG #2) has been fixed. The problem was that
; async functions were being called with the wrong convention:
;   (async-fn item continuation)    <- wrong (passing 2 args)
;   ((async-fn item) continuation)  <- correct (returns async op, then call it)

; ============================================================================
; http2/fan-out tests
; ============================================================================

; ============================================================================
; http2/aggregate tests
; ============================================================================

; ============================================================================
; Retry failure path tests
; ============================================================================

; ============================================================================
; http2/fetch-all-text pattern test
; ============================================================================

(test/run (list
  (test "http2/response-ok? returns true for 200"
    {do
    (def {resp} (http2/mock-response "200" "OK"))
    (== 1 (http2/response-ok? resp))
  })
  (test "http2/response-ok? returns true for 201"
    {do
    (def {resp} (http2/mock-response "201" "Created"))
    (== 1 (http2/response-ok? resp))
  })
  (test "http2/response-ok? returns true for 299"
    {do
    (def {resp} (http2/mock-response "299" "Custom Success"))
    (== 1 (http2/response-ok? resp))
  })
  (test "http2/response-ok? returns false for 404"
    {do
    (def {resp} (http2/mock-response "404" "Not Found"))
    (== 0 (http2/response-ok? resp))
  })
  (test "http2/response-ok? returns false for 500"
    {do
    (def {resp} (http2/mock-response "500" "Internal Server Error"))
    (== 0 (http2/response-ok? resp))
  })
  (test "http2/response-ok? returns false for 199"
    {do
    (def {resp} (http2/mock-response "199" "Informational"))
    (== 0 (http2/response-ok? resp))
  })
  (test "http2/response-ok? returns false for 300"
    {do
    (def {resp} (http2/mock-response "300" "Multiple Choices"))
    (== 0 (http2/response-ok? resp))
  })
  (test "http2/response-body returns body"
    {do
    (def {resp} (http2/mock-response "200" "Hello, World!"))
    (== (http2/response-body resp) "Hello, World!")
  })
  (test "http2/response-status returns status"
    {do
    (def {resp} (http2/mock-response "404" "Not Found"))
    (== (http2/response-status resp) "404")
  })
  (test "http2/response-body handles empty body"
    {do
    (def {resp} (http2/mock-response "204" ""))
    (== (http2/response-body resp) "")
  })
  (test "http2/response-headers returns empty list for no headers"
    {do
    (def {resp} (http2/mock-response "200" "body"))
    (def {headers} (http2/response-headers resp))
    (== headers nil)
  })
  (test "http2/mock-response accepts headers"
    {do
    (def {hdrs} (list (list "content-type" "application/json") (list "x-custom" "value")))
    (def {resp} (http2/mock-response "200" "body" hdrs))
    (def {headers} (http2/response-headers resp))
    (!= headers nil)
  })
  (test "http2/log-response logs and returns response"
    {do
    (def {resp} (http2/mock-response "200" "Test body"))
    ; log-response should return the response unchanged
    (def {result} (http2/log-response resp))
    (== (http2/response-body result) "Test body")
  })
  (test "http2/log-response works with error responses"
    {do
    (def {resp} (http2/mock-response "500" "Server Error"))
    (def {result} (http2/log-response resp))
    (== (http2/response-status result) "500")
  })
  (test "http2/validate-status returns response on match"
    {do
    (def {resp} (http2/mock-response "200" "OK"))
    (def {validator} (http2/validate-status 200))
    (def {result} (validator resp))
    (== (http2/response-body result) "OK")
  })
  (test "http2/validate-status returns error on mismatch"
    {do
    (= {resp} (http2/mock-response "404" "Not Found"))
    (= {validator} (http2/validate-status 200))
    ; Check error? directly without storing the error in a variable
    (== 1 (error? (validator resp)))
  })
  (test "http2/parallel collects multiple results"
    {do
    (def {r1} (http2/mock-response "200" "first"))
    (def {r2} (http2/mock-response "200" "second"))
    (def {ops} (list (async/pure r1) (async/pure r2)))
    (def {par} (http2/parallel ops))
    (def {result} nil)
    (par (\ {x} {(def {result} x)}))
    (== (len result) 2)
  })
  (test "http2/sequential returns last result"
    {do
    (def {r1} (http2/mock-response "200" "first"))
    (def {r2} (http2/mock-response "200" "second"))
    (def {ops} (list (async/pure r1) (async/pure r2)))
    (def {seq} (http2/sequential ops))
    (def {result} nil)
    (seq (\ {x} {(def {result} x)}))
    (== (http2/response-body result) "second")
  })
  (test "middleware chain with response handling"
    {do
    ; Create a request, apply middleware, check result
    (def {req} (http2/get "example.com"))
    (def {mw} (http2/compose-middleware (list
      (http2/with-auth "Bearer token")
      (http2/with-user-agent "TestAgent/1.0"))))
    (def {req2} (mw req))
    ; Now simulate getting a response
    (def {resp} (http2/mock-response "200" "Success"))
    (== 1 (http2/response-ok? resp))
  })
  (test "validate-status in pipeline"
    {do
    (def {resp} (http2/mock-response "201" "Created"))
    (def {validator} (http2/validate-status 201))
    (def {logged} (http2/log-response resp))
    (def {validated} (validator logged))
    (== (http2/response-body validated) "Created")
  })
  (test "response with special characters in body"
    {do
    (def {body} "Hello
World	withspecial chars: <>\"'&")
    (def {resp} (http2/mock-response "200" body))
    (== (http2/response-body resp) body)
  })
  (test "response with unicode in body"
    {do
    (def {body} "Hello World!")
    (def {resp} (http2/mock-response "200" body))
    (== (http2/response-body resp) body)
  })
  (test "response with large body"
    {do
    ; Build a 10KB body
    (def {chunk} "0123456789ABCDEF")  ; 16 bytes
    (def {body-1k} (str chunk chunk chunk chunk chunk chunk chunk chunk
                        chunk chunk chunk chunk chunk chunk chunk chunk
                        chunk chunk chunk chunk chunk chunk chunk chunk
                        chunk chunk chunk chunk chunk chunk chunk chunk
                        chunk chunk chunk chunk chunk chunk chunk chunk
                        chunk chunk chunk chunk chunk chunk chunk chunk
                        chunk chunk chunk chunk chunk chunk chunk chunk
                        chunk chunk chunk chunk chunk chunk chunk chunk))
    (def {body-10k} (str body-1k body-1k body-1k body-1k body-1k
                         body-1k body-1k body-1k body-1k body-1k))
    (def {resp} (http2/mock-response "200" body-10k))
    (== (len (http2/response-body resp)) (len body-10k))
  })
  (test "http2/validate-status 201 matches 201"
    {do
    (def {resp} (http2/mock-response "201" "Created"))
    (def {validator} (http2/validate-status 201))
    (def {result} (validator resp))
    (== (http2/response-body result) "Created")
  })
  (test "http2/validate-status 404 matches 404"
    {do
    (def {resp} (http2/mock-response "404" "Not Found"))
    (def {validator} (http2/validate-status 404))
    (def {result} (validator resp))
    (== (http2/response-status result) "404")
  })
  (test "async/run executes async operation synchronously"
    {do
    (def {result} (async/run (async/pure 42)))
    (== result 42)
  })
  (test "async/bind chains pure operations"
    {do
    (def {result} nil)
    (def {op} (async/bind (async/pure 10) (\ {x} {
      (async/pure (* x 2))
    })))
    (op (\ {x} {(def {result} x)}))
    (== result 20)
  })
  (test "mock-fetch returns async response"
    {do
    (def {result} nil)
    (def {op} (mock-fetch "test"))
    (op (\ {x} {(def {result} x)}))
    (== (http2/response-status result) "200")
  })
  (test "async/map-list with pure values"
    {do
    (def {double-async} (\ {x} {
      (async/pure (* x 2))
    }))
    (def {result} (async/run (async/map-list double-async (list 1 2 3))))
    (== result (list 2 4 6))
  })
  (test "http2/fan-out with single extractor"
    {do
    (= {resp} (http2/mock-response "200" "single"))
    (= {ext} (\ {r} {(list "localhost" 8080 "/")}))
    (= {endpoints} (map (\ {e} {(e resp)}) (list ext)))
    (== (len endpoints) 1)
  })
  (test "http2/fan-out two extractors"
    {do
    (= {resp} (http2/mock-response "200" "data"))
    (= {ext1} (\ {r} {(list "host1" 80 "/path1")}))
    (= {ext2} (\ {r} {(list "host2" 80 "/path2")}))
    (= {results} (map (\ {e} {(e resp)}) (list ext1 ext2)))
    (== (len results) 2)
  })
  (test "http2/aggregate combiner counts responses"
    {do
    (= {r1} (http2/mock-response "200" "first"))
    (= {r2} (http2/mock-response "200" "second"))
    (= {r3} (http2/mock-response "200" "third"))
    (= {count-combiner} (\ {responses} {(len responses)}))
    (= {responses} (list r1 r2 r3))
    (= {result} (count-combiner responses))
    (== result 3)
  })
  (test "http2/aggregate async pattern"
    {do
    (= {r1} (http2/mock-response "200" "a"))
    (= {r2} (http2/mock-response "200" "b"))
    (= {combiner} (\ {rs} {(len rs)}))
    (= {agg-op} (async/bind
      (async/pure (list r1 r2))
      (\ {responses} {(async/pure (combiner responses))})
    ))
    (= {result} (async/run agg-op))
    (== result 2)
  })
  (test "http2/fetch-retry detects non-200"
    {do
    (= {fail-resp} (http2/mock-response "404" "Not Found"))
    (= {success-resp} (http2/mock-response "200" "Success"))
    (and
      (== 0 (http2/response-ok? fail-resp))
      (== 1 (http2/response-ok? success-resp)))
  })
  (test "retry path for 500 status"
    {do
    (= {resp} (http2/mock-response "500" "Server Error"))
    (== 0 (http2/response-ok? resp))
  })
  (test "retry path for 503 status"
    {do
    (= {resp} (http2/mock-response "503" "Service Unavailable"))
    (== 0 (http2/response-ok? resp))
  })
  (test "http2/fetch-all-text pattern"
    {do
    (= {r1} (http2/mock-response "200" "text1"))
    (= {r2} (http2/mock-response "200" "text2"))
    (= {extract-body} (\ {resp} {(async/pure (http2/response-body resp))}))
    (= {op} (async/map-list extract-body (list r1 r2)))
    (= {result} (async/run op))
    (== result (list "text1" "text2"))
  }))
  {:suite-name "HTTP Integration Tests"})
