; Backpressure Stress Test
; Creates many concurrent connections to exhaust buffer pool and trigger backpressure
; This exercises: __backpressure_list_add, __backpressure_list_remove, 
;                 __backpressure_try_resume_one, __backpressure_timer_cb

(load "src/prelude.valk")

(def {TEST_PORT} 8491)

; Start with minimal buffer pool to trigger backpressure quickly
; tcp-buffer-pool-size must be >= max-connections
; But we set both low so buffers exhaust quickly under load
; Use short backpressure-timeout to exercise timeout path
(def {aio} (aio/start {
  :max-connections 20
  :tcp-buffer-pool-size 20
  :backpressure-timeout-ms 2000
}))

(def {requests-completed} 0)
(def {requests-started} 0)
(def {errors} 0)

; Handler that takes some time - this holds connections open longer
; which helps trigger backpressure recovery paths
(def {handler}
  (\ {req} {
    (aio/then (aio/sleep 50) (\ {_} {{:status "200" :body "OK"}}))
  }))

(println "")
(println "=== Backpressure Stress Test ===")
(println "")
(printf "Config: tcp-buffer-pool-size=20, max-connections=20, timeout=2000ms\n")
(printf "Starting server on port %d\n" TEST_PORT)
(http2/server-listen aio TEST_PORT handler)

; Function to make a burst of requests
(fun {make-requests n} {
  (if (<= n 0)
    {nil}
    {(do
      (def {requests-started} (+ requests-started 1))
      (http2/client-request aio "127.0.0.1" TEST_PORT "/" (\ {resp} {
        (if (error? resp)
          {(def {errors} (+ errors 1))}
          {(def {requests-completed} (+ requests-completed 1))})
      }))
      (make-requests (- n 1)))})
})

; Schedule bursts of requests to create pressure
; Spread them out more to allow backpressure timer to run between bursts
(aio/schedule aio 100 (\ {} {
  (println "Burst 1: Starting 15 concurrent requests...")
  (make-requests 15)
}))

(aio/schedule aio 500 (\ {} {
  (println "Burst 2: Starting 15 more concurrent requests...")
  (make-requests 15)
}))

(aio/schedule aio 1000 (\ {} {
  (println "Burst 3: Starting 15 more concurrent requests...")
  (make-requests 15)
}))

(aio/schedule aio 1500 (\ {} {
  (println "Burst 4: Starting 15 more concurrent requests...")
  (make-requests 15)
}))

(aio/schedule aio 2000 (\ {} {
  (println "Burst 5: Starting 15 more concurrent requests...")
  (make-requests 15)
}))

; Wait longer for backpressure recovery to happen
(aio/schedule aio 5000 (\ {} {
  (println "")
  (printf "=== Results ===\n")
  (printf "Requests started: %d\n" requests-started)
  (printf "Requests completed: %d\n" requests-completed)
  (printf "Errors: %d\n" errors)
  (println "")
  
  ; Success if we completed some requests - the point is to exercise backpressure
  ; Even 1 completed request means the system handled the load
  (if (> requests-completed 0)
    {(do
      (println "PASS: Backpressure test completed successfully")
      (exit 0))}
    {(do
      (println "FAIL: No requests completed")
      (exit 1))})
}))

; Timeout - just exit, don't stop aio (avoids cleanup race)
(aio/schedule aio 15000 (\ {} {
  (println "TIMEOUT!")
  (exit 1)
}))

(aio/run aio)
