; Parser Coverage Gap Tests
; Run with: ./build/valk test/test_parser_coverage_gaps.valk

(load "src/prelude.valk")
(load "src/modules/test.valk")

(test/suite "Parser Coverage Gap Tests")

; === Quasiquote coverage gaps ===

; Line 868: Empty form in quasiquote (LVAL_NIL check)
(test/define "quasiquote-nil-form"
  {do
    ; Pass nil directly to quasiquote
    (= {result} (eval (list (quote quasiquote) nil)))
    (test/assert (== result nil) "quasiquote of nil returns nil")
    true
  })

; Line 874: unquote with wrong number of args (not exactly 1)
(test/define "quasiquote-unquote-zero-args"
  {do
    ; Build (quasiquote (unquote)) - unquote with no args
    (= {form} (list (quote quasiquote) (list (quote unquote))))
    (= {result} (error? (eval form)))
    (test/assert result "unquote with zero args should error")
    true
  })

(test/define "quasiquote-unquote-multiple-args"
  {do
    ; Build (quasiquote (unquote 1 2)) - unquote with 2 args
    (= {form} (list (quote quasiquote) (list (quote unquote) 1 2)))
    (= {result} (error? (eval form)))
    (test/assert result "unquote with multiple args should error")
    true
  })

; Line 882: unquote-splicing at top level
(test/define "quasiquote-splice-top-level"
  {do
    ; Build (quasiquote (unquote-splicing (list 1 2 3)))
    (= {form} (list (quote quasiquote) (list (quote unquote-splicing) (list (quote list) 1 2 3))))
    (= {result} (error? (eval form)))
    (test/assert result "unquote-splicing at top level should error")
    true
  })

; Line 901: unquote-splicing with wrong number of args
(test/define "quasiquote-splice-zero-args"
  {do
    ; Build (quasiquote {a (unquote-splicing) b})
    (= {form} (list (quote quasiquote) {a (unquote-splicing) b}))
    (= {result} (error? (eval form)))
    (test/assert result "unquote-splicing with zero args should error")
    true
  })

(test/define "quasiquote-splice-multiple-args"
  {do
    ; Build (quasiquote {a (unquote-splicing x y) b}) with x={1 2}, y={3 4}
    (= {x} {1 2})
    (= {form} (list (quote quasiquote) (list (quote a) (list (quote unquote-splicing) (quote x) (quote y)) (quote b))))
    (= {result} (error? (eval form)))
    (test/assert result "unquote-splicing with multiple args should error")
    true
  })

; Line 906: Error propagation from splice evaluation
(test/define "quasiquote-splice-eval-error"
  {do
    ; Build `{a ,@(/ 1 0) b} - splice of expression that errors
    (= {result} (error? `{a ,@(/ 1 0) b}))
    (test/assert result "unquote-splicing error should propagate")
    true
  })

; Lines 936-940: Capacity growth in quasiquote (need >16 elements without splicing)
(test/define "quasiquote-large-list-no-splice"
  {do
    ; Build a large quasiquoted list with >16 elements to trigger capacity growth
    (= {a} 1)
    (= {result} `{1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ,a 19 20})
    (test/assert-eq 20 (len result) "large quasiquote list should have correct length")
    (test/assert-eq 1 (nth 18 result) "unquoted element should be correct")
    true
  })

; Line 953: Building CONS (non-quoted) result in quasiquote
(test/define "quasiquote-cons-result"
  {do
    ; When quasiquoting a cons (non-qexpr) list, result should be cons
    (= {x} 2)
    ; Create an unquoted cons list by evaluating to one
    (= {form} (list (quote quasiquote) (cons (quote a) (cons x (cons (quote c) nil)))))
    (= {result} (eval form))
    (test/assert-eq 3 (len result) "cons quasiquote should have 3 elements")
    (test/assert-eq 2 (nth 2 result) "unquoted value should be evaluated")
    true
  })

; === Context continuation coverage gaps ===

; Lines 1437-1438: CONT_CTX_DEADLINE error propagation (error before timeout evaluation)
; This is tested in test_parser_continuations.valk already

; Lines 1469-1476: CONT_CTX_DEADLINE multiple body evaluation
(test/define "ctx-deadline-multi-body-all-execute"
  {do
    (= {counter} 0)
    (= {result} (ctx/with-deadline 5000
                  (= {counter} (+ counter 1))
                  (= {counter} (+ counter 1))
                  (= {counter} (+ counter 1))
                  counter))
    (test/assert-eq 3 result "ctx/with-deadline multi-body returns last value")
    (test/assert-eq 3 counter "ctx/with-deadline multi-body executes all expressions")
    true
  })

; Lines 1481-1482: CONT_CTX_WITH error in key evaluation
(test/define "ctx-with-key-error"
  {do
    (= {result} (ctx/with (error "key error") "value" (+ 1 2)))
    (test/assert (error? result) "ctx/with propagates key evaluation error")
    true
  })

; Lines 1489-1491: CONT_CTX_WITH error in value evaluation
(test/define "ctx-with-value-error-propagation"
  {do
    (= {result} (ctx/with :key (error "value error") (+ 1 2)))
    (test/assert (error? result) "ctx/with propagates value evaluation error")
    true
  })

; Lines 1500-1502: CONT_CTX_WITH empty body
(test/define "ctx-with-empty-body-nil"
  {do
    (= {result} (ctx/with :key "value"))
    (test/assert (== result nil) "ctx/with with empty body returns nil")
    true
  })

; Lines 1516-1523: CONT_CTX_WITH multiple body expressions
(test/define "ctx-with-multi-body-all-execute"
  {do
    (= {counter} 0)
    (= {result} (ctx/with :key "value"
                  (= {counter} (+ counter 1))
                  (= {counter} (+ counter 1))
                  (= {counter} (+ counter 1))
                  counter))
    (test/assert-eq 3 result "ctx/with multi-body returns last value")
    (test/assert-eq 3 counter "ctx/with multi-body executes all expressions")
    true
  })

; === Varargs error paths ===

; Lines 1007-1009: & not followed by varargs name (in argument binding phase)
(test/define "varargs-ampersand-alone-in-call"
  {do
    ; Create lambda with just & as last formal
    (= {result} (error? (eval (read "((\\ {&} {1}) 1 2 3)"))))
    (test/assert result "varargs & without name should error on call")
    true
  })

; Lines 1038-1040: & not followed by varargs name (when more args remain)
(test/define "varargs-ampersand-alone-partial"
  {do
    ; Create partial application that would hit this path
    (= {result} (error? (eval (read "((\\ {x &} {x}) 1)"))))
    (test/assert result "varargs & without name should error in partial")
    true
  })

; === Lines 1160-1162: Empty list evaluation ===
(test/define "eval-empty-cons"
  {do
    ; Evaluating () should return nil
    (= {empty-list} (list))
    (= {result} (eval empty-list))
    (test/assert (== result nil) "eval of empty cons returns nil")
    true
  })

; === Lines 1190-1191: quasiquote wrong args in eval ===
(test/define "quasiquote-no-args-eval"
  {do
    (= {form} (list (quote quasiquote)))
    (= {result} (error? (eval form)))
    (test/assert result "quasiquote with no args should error")
    true
  })

(test/define "quasiquote-too-many-args-eval"
  {do
    (= {form} (list (quote quasiquote) 1 2))
    (= {result} (error? (eval form)))
    (test/assert result "quasiquote with too many args should error")
    true
  })

; === Line 994: func->fun.env fallback to parent env ===
(test/define "lambda-no-captured-env"
  {do
    ; Lambda without closure should use call environment
    (= {x} 10)
    (= {f} (\ {y} {+ x y}))
    (= {result} (f 5))
    (test/assert-eq 15 result "lambda should find x in parent env")
    true
  })

; === Line 848: Empty list in valk_is_tagged_list ===
(test/define "tagged-list-check-nil"
  {do
    ; Trigger valk_is_tagged_list with nil - happens in quasiquote expansion
    ; When recursively expanding an empty list element
    (= {result} `{a {} b})
    (test/assert-eq 3 (len result) "quasiquote with empty list element works")
    true
  })

; === GC builtins coverage ===

; Lines 3715-3720: gc-stats builtin
(test/define "gc-stats-runs"
  {do
    (gc-stats)
    (test/assert true "gc-stats runs without error")
    true
  })

; Lines 3724-3734: gc-collect builtin
(test/define "gc-collect-runs"
  {do
    (= {result} (gc-collect))
    (test/assert (>= result 0) "gc-collect returns bytes reclaimed")
    true
  })

; Lines 3760-3771: set-heap-hard-limit error path
(test/define "set-heap-hard-limit-below-usage"
  {do
    (= {current-usage} (heap-usage))
    ; Try to set limit below current usage
    (= {result} (error? (set-heap-hard-limit 1)))
    (test/assert result "set-heap-hard-limit below usage should error")
    true
  })

; Line 3778: gc-threshold-pct null heap
; This is hard to test since we always have a heap in normal operation

; === GC threshold percentage builtins ===
(test/define "gc-threshold-pct-get"
  {do
    (= {pct} (gc-threshold-pct))
    (test/assert (and (>= pct 1) (<= pct 100)) "gc-threshold-pct returns valid percentage")
    true
  })

(test/define "gc-threshold-pct-set-restore"
  {do
    (= {old-pct} (gc-threshold-pct))
    (= {returned} (set-gc-threshold-pct 50))
    (= {new-pct} (gc-threshold-pct))
    ; Restore original
    (set-gc-threshold-pct old-pct)
    (test/assert-eq old-pct returned "set-gc-threshold-pct returns old value")
    (test/assert-eq 50 new-pct "gc-threshold-pct was changed")
    true
  })

(test/define "gc-threshold-pct-clamp-low"
  {do
    (= {old-pct} (gc-threshold-pct))
    (set-gc-threshold-pct 0)
    (= {clamped} (gc-threshold-pct))
    (set-gc-threshold-pct old-pct)
    (test/assert-eq 1 clamped "gc-threshold-pct clamps to minimum 1")
    true
  })

(test/define "gc-threshold-pct-clamp-high"
  {do
    (= {old-pct} (gc-threshold-pct))
    (set-gc-threshold-pct 200)
    (= {clamped} (gc-threshold-pct))
    (set-gc-threshold-pct old-pct)
    (test/assert-eq 100 clamped "gc-threshold-pct clamps to maximum 100")
    true
  })

; === Math builtin coverage gaps ===

; Line 2338: non-number type error in math
(test/define "math-non-number-error"
  {do
    (= {result} (error? (+ 1 "two")))
    (test/assert result "math with non-number should error")
    true
  })

; Lines 2347-2348: unary negation
(test/define "math-unary-negation"
  {do
    (test/assert-eq -5 (- 5) "unary minus should negate")
    (test/assert-eq -42 (- 42) "unary minus on larger number")
    true
  })

; === List builtins coverage gaps ===

; Line 2404: len on invalid type
(test/define "len-invalid-type"
  {do
    (= {result} (error? (len 42)))
    (test/assert result "len on number should error")
    true
  })

; Lines 2437-2438: init on empty list
(test/define "init-empty-list"
  {do
    (= {lst} {1})
    (= {result} (init lst))
    (test/assert (== result nil) "init of single-element list returns nil")
    true
  })

; Lines 2447-2452: init on QEXPR vs CONS
(test/define "init-qexpr-preserves-type"
  {do
    (= {lst} {1 2 3})
    (= {result} (init lst))
    (test/assert-eq 2 (len result) "init removes last element")
    (test/assert-eq 1 (nth 1 result) "init first element correct")
    (test/assert-eq 2 (nth 2 result) "init second element correct")
    true
  })

(test/define "init-cons-preserves-type"
  {do
    (= {lst} (list 1 2 3))
    (= {result} (init lst))
    (test/assert-eq 2 (len result) "init on cons removes last element")
    true
  })

; === Parser error paths ===

; Line 1906: Unexpected end of input during parsing
(test/define "read-unterminated-string"
  {do
    (= {result} (error? (read "\"unterminated")))
    (test/assert result "unterminated string should error")
    true
  })

; Line 1914: Error propagation in quote parsing
(test/define "read-quote-error"
  {do
    (= {result} (error? (read "'\"unterminated")))
    (test/assert result "quote of unterminated string should error")
    true
  })

; Line 1924: Error propagation in quasiquote parsing
(test/define "read-quasiquote-error"
  {do
    (= {result} (error? (read "`\"unterminated")))
    (test/assert result "quasiquote of unterminated string should error")
    true
  })

; === Escape sequence coverage ===

; Line 1769: unknown escape returns null char
(test/define "escape-unknown-sequence"
  {do
    ; Test that strings with standard escapes work
    (= {s1} "\t")
    (test/assert-eq 1 (len s1) "tab escape has length 1")
    true
  })

; Lines 1783, 1793-1795: escape sequence output
(test/define "escape-carriage-return"
  {do
    (= {s} "\r")
    (test/assert-eq 1 (len s) "carriage return escape has length 1")
    true
  })

(test/define "escape-quote-in-string"
  {do
    (= {s} "say \"hello\"")
    (test/assert-eq 11 (len s) "string with escaped quotes has correct length")
    true
  })

; === Empty list and continuation paths ===

; Lines 1500-1502: CONT_CTX_WITH empty body returns nil (already tested above)

; Lines 1307-1313: CONT_EVAL_ARGS with no remaining args and thunk
(test/define "eval-args-no-remaining-thunk"
  {do
    ; This tests the path where a function is called with no args but returns a thunk
    (= {f} (\ {} {42}))
    (= {result} (f))
    (test/assert-eq 42 result "no-arg function returns value")
    true
  })

; Lines 1527-1528: Unknown continuation type (defensive, hard to trigger)
; This should never happen in normal operation

; === Env operations coverage ===

; Line 2176: null symbol in env search (defensive check)
(test/define "env-lookup-basic"
  {do
    (= {x} 42)
    (test/assert-eq 42 x "basic env lookup works")
    true
  })

; Lines 2180-2181: trace logging (only with VALK_LOG=trace)
; Lines 2217-2218: debug logging (only with VALK_LOG=debug)
; These require environment variable configuration

; Line 2209: Region promotion path
(test/define "env-put-value-survives"
  {do
    (= {outer} 10)
    (= {f} (\ {x} {+ x outer}))
    (= {result} (f 5))
    (test/assert-eq 15 result "closure captures env values correctly")
    true
  })

; Line 2241: No heap, use thread ctx allocator (rare path)
; This is hard to test without modifying the runtime

; === Coverage builtins (only in VALK_COVERAGE builds) ===
; Lines 5003-5057 are only compiled with VALK_COVERAGE flag
; These are tested by running the coverage build itself

; === THUNK continuation paths ===

; Lines 1553-1555: CONT_THUNK with remaining args
(test/define "thunk-with-remaining-body"
  {do
    ; A function that returns a partial that takes more args
    (= {add3} (\ {a b c} {+ a (+ b c)}))
    (= {partial} (add3 1))
    (= {result} (partial 2 3))
    (test/assert-eq 6 result "thunk partial application works")
    true
  })

; === More list operation coverage ===

(test/define "last-single-element"
  {do
    (= {result} (last {42}))
    (test/assert-eq 42 result "last of single element list")
    true
  })

(test/define "last-multi-element"
  {do
    (= {result} (last {1 2 3 4 5}))
    (test/assert-eq 5 result "last of multi element list")
    true
  })

; === Type predicates ===

(test/define "num-predicate"
  {do
    (test/assert (num? 42) "num? on number returns true")
    (test/assert (not (num? "hello")) "num? on string returns false")
    true
  })

(test/define "str-predicate"
  {do
    (test/assert (str? "hello") "str? on string returns true")
    (test/assert (not (str? 42)) "str? on number returns false")
    true
  })

(test/define "sym-predicate"
  {do
    (test/assert (sym? (quote foo)) "sym? on symbol returns true")
    (test/assert (not (sym? 42)) "sym? on number returns false")
    true
  })

(test/define "fun-predicate"
  {do
    (test/assert (fun? +) "fun? on builtin returns true")
    (test/assert (fun? (\ {x} {x})) "fun? on lambda returns true")
    (test/assert (not (fun? 42)) "fun? on number returns false")
    true
  })

(test/run)
