; Parser Coverage Gap Tests
; Run with: ./build/valk test/test_parser_coverage_gaps.valk

(load "src/prelude.valk")
(load "src/modules/test.valk")

(test/suite "Parser Coverage Gap Tests")

; === Quasiquote coverage gaps ===

; Line 868: Empty form in quasiquote (LVAL_NIL check)
(test/define "quasiquote-nil-form"
  {do
    ; Pass nil directly to quasiquote
    (= {result} (eval (list (quote quasiquote) nil)))
    (test/assert (== result nil) "quasiquote of nil returns nil")
    true
  })

; Line 874: unquote with wrong number of args (not exactly 1)
(test/define "quasiquote-unquote-zero-args"
  {do
    ; Build (quasiquote (unquote)) - unquote with no args
    (= {form} (list (quote quasiquote) (list (quote unquote))))
    (= {result} (error? (eval form)))
    (test/assert result "unquote with zero args should error")
    true
  })

(test/define "quasiquote-unquote-multiple-args"
  {do
    ; Build (quasiquote (unquote 1 2)) - unquote with 2 args
    (= {form} (list (quote quasiquote) (list (quote unquote) 1 2)))
    (= {result} (error? (eval form)))
    (test/assert result "unquote with multiple args should error")
    true
  })

; Line 882: unquote-splicing at top level
(test/define "quasiquote-splice-top-level"
  {do
    ; Build (quasiquote (unquote-splicing (list 1 2 3)))
    (= {form} (list (quote quasiquote) (list (quote unquote-splicing) (list (quote list) 1 2 3))))
    (= {result} (error? (eval form)))
    (test/assert result "unquote-splicing at top level should error")
    true
  })

; Line 901: unquote-splicing with wrong number of args
(test/define "quasiquote-splice-zero-args"
  {do
    ; Build (quasiquote {a (unquote-splicing) b})
    (= {form} (list (quote quasiquote) {a (unquote-splicing) b}))
    (= {result} (error? (eval form)))
    (test/assert result "unquote-splicing with zero args should error")
    true
  })

(test/define "quasiquote-splice-multiple-args"
  {do
    ; Build (quasiquote {a (unquote-splicing x y) b}) with x={1 2}, y={3 4}
    (= {x} {1 2})
    (= {form} (list (quote quasiquote) (list (quote a) (list (quote unquote-splicing) (quote x) (quote y)) (quote b))))
    (= {result} (error? (eval form)))
    (test/assert result "unquote-splicing with multiple args should error")
    true
  })

; Line 906: Error propagation from splice evaluation
(test/define "quasiquote-splice-eval-error"
  {do
    ; Build `{a ,@(/ 1 0) b} - splice of expression that errors
    (= {result} (error? `{a ,@(/ 1 0) b}))
    (test/assert result "unquote-splicing error should propagate")
    true
  })

; Lines 936-940: Capacity growth in quasiquote (need >16 elements without splicing)
(test/define "quasiquote-large-list-no-splice"
  {do
    ; Build a large quasiquoted list with >16 elements to trigger capacity growth
    (= {a} 1)
    (= {result} `{1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ,a 19 20})
    (test/assert-eq 20 (len result) "large quasiquote list should have correct length")
    (test/assert-eq 1 (nth 18 result) "unquoted element should be correct")
    true
  })

; Line 953: Building CONS (non-quoted) result in quasiquote
(test/define "quasiquote-cons-result"
  {do
    ; When quasiquoting a cons (non-qexpr) list, result should be cons
    (= {x} 2)
    ; Create an unquoted cons list by evaluating to one
    (= {form} (list (quote quasiquote) (cons (quote a) (cons x (cons (quote c) nil)))))
    (= {result} (eval form))
    (test/assert-eq 3 (len result) "cons quasiquote should have 3 elements")
    (test/assert-eq 2 (nth 2 result) "unquoted value should be evaluated")
    true
  })

; === Context continuation coverage gaps ===

; Lines 1437-1438: CONT_CTX_DEADLINE error propagation (error before timeout evaluation)
; This is tested in test_parser_continuations.valk already

; Lines 1469-1476: CONT_CTX_DEADLINE multiple body evaluation
(test/define "ctx-deadline-multi-body-all-execute"
  {do
    (= {counter} 0)
    (= {result} (ctx/with-deadline 5000
                  (= {counter} (+ counter 1))
                  (= {counter} (+ counter 1))
                  (= {counter} (+ counter 1))
                  counter))
    (test/assert-eq 3 result "ctx/with-deadline multi-body returns last value")
    (test/assert-eq 3 counter "ctx/with-deadline multi-body executes all expressions")
    true
  })

; Lines 1481-1482: CONT_CTX_WITH error in key evaluation
(test/define "ctx-with-key-error"
  {do
    (= {result} (ctx/with (error "key error") "value" (+ 1 2)))
    (test/assert (error? result) "ctx/with propagates key evaluation error")
    true
  })

; Lines 1489-1491: CONT_CTX_WITH error in value evaluation
(test/define "ctx-with-value-error-propagation"
  {do
    (= {result} (ctx/with :key (error "value error") (+ 1 2)))
    (test/assert (error? result) "ctx/with propagates value evaluation error")
    true
  })

; Lines 1500-1502: CONT_CTX_WITH empty body
(test/define "ctx-with-empty-body-nil"
  {do
    (= {result} (ctx/with :key "value"))
    (test/assert (== result nil) "ctx/with with empty body returns nil")
    true
  })

; Lines 1516-1523: CONT_CTX_WITH multiple body expressions
(test/define "ctx-with-multi-body-all-execute"
  {do
    (= {counter} 0)
    (= {result} (ctx/with :key "value"
                  (= {counter} (+ counter 1))
                  (= {counter} (+ counter 1))
                  (= {counter} (+ counter 1))
                  counter))
    (test/assert-eq 3 result "ctx/with multi-body returns last value")
    (test/assert-eq 3 counter "ctx/with multi-body executes all expressions")
    true
  })

; === Varargs error paths ===

; Lines 1007-1009: & not followed by varargs name (in argument binding phase)
(test/define "varargs-ampersand-alone-in-call"
  {do
    ; Create lambda with just & as last formal
    (= {result} (error? (eval (read "((\\ {&} {1}) 1 2 3)"))))
    (test/assert result "varargs & without name should error on call")
    true
  })

; Lines 1038-1040: & not followed by varargs name (when more args remain)
(test/define "varargs-ampersand-alone-partial"
  {do
    ; Create partial application that would hit this path
    (= {result} (error? (eval (read "((\\ {x &} {x}) 1)"))))
    (test/assert result "varargs & without name should error in partial")
    true
  })

; === Lines 1160-1162: Empty list evaluation ===
(test/define "eval-empty-cons"
  {do
    ; Evaluating () should return nil
    (= {empty-list} (list))
    (= {result} (eval empty-list))
    (test/assert (== result nil) "eval of empty cons returns nil")
    true
  })

; === Lines 1190-1191: quasiquote wrong args in eval ===
(test/define "quasiquote-no-args-eval"
  {do
    (= {form} (list (quote quasiquote)))
    (= {result} (error? (eval form)))
    (test/assert result "quasiquote with no args should error")
    true
  })

(test/define "quasiquote-too-many-args-eval"
  {do
    (= {form} (list (quote quasiquote) 1 2))
    (= {result} (error? (eval form)))
    (test/assert result "quasiquote with too many args should error")
    true
  })

; === Line 994: func->fun.env fallback to parent env ===
(test/define "lambda-no-captured-env"
  {do
    ; Lambda without closure should use call environment
    (= {x} 10)
    (= {f} (\ {y} {+ x y}))
    (= {result} (f 5))
    (test/assert-eq 15 result "lambda should find x in parent env")
    true
  })

; === Line 848: Empty list in valk_is_tagged_list ===
(test/define "tagged-list-check-nil"
  {do
    ; Trigger valk_is_tagged_list with nil - happens in quasiquote expansion
    ; When recursively expanding an empty list element
    (= {result} `{a {} b})
    (test/assert-eq 3 (len result) "quasiquote with empty list element works")
    true
  })

; === GC builtins coverage ===

; Lines 3715-3720: gc-stats builtin
(test/define "gc-stats-runs"
  {do
    (gc-stats)
    (test/assert true "gc-stats runs without error")
    true
  })

; Lines 3724-3734: gc-collect builtin
(test/define "gc-collect-runs"
  {do
    (= {result} (gc-collect))
    (test/assert (>= result 0) "gc-collect returns bytes reclaimed")
    true
  })

; Lines 3760-3771: set-heap-hard-limit error path
(test/define "set-heap-hard-limit-below-usage"
  {do
    (= {current-usage} (heap-usage))
    ; Try to set limit below current usage
    (= {result} (error? (set-heap-hard-limit 1)))
    (test/assert result "set-heap-hard-limit below usage should error")
    true
  })

; Line 3778: gc-threshold-pct null heap
; This is hard to test since we always have a heap in normal operation

; === GC threshold percentage builtins ===
(test/define "gc-threshold-pct-get"
  {do
    (= {pct} (gc-threshold-pct))
    (test/assert (and (>= pct 1) (<= pct 100)) "gc-threshold-pct returns valid percentage")
    true
  })

(test/define "gc-threshold-pct-set-restore"
  {do
    (= {old-pct} (gc-threshold-pct))
    (= {returned} (set-gc-threshold-pct 50))
    (= {new-pct} (gc-threshold-pct))
    ; Restore original
    (set-gc-threshold-pct old-pct)
    (test/assert-eq old-pct returned "set-gc-threshold-pct returns old value")
    (test/assert-eq 50 new-pct "gc-threshold-pct was changed")
    true
  })

(test/define "gc-threshold-pct-clamp-low"
  {do
    (= {old-pct} (gc-threshold-pct))
    (set-gc-threshold-pct 0)
    (= {clamped} (gc-threshold-pct))
    (set-gc-threshold-pct old-pct)
    (test/assert-eq 1 clamped "gc-threshold-pct clamps to minimum 1")
    true
  })

(test/define "gc-threshold-pct-clamp-high"
  {do
    (= {old-pct} (gc-threshold-pct))
    (set-gc-threshold-pct 200)
    (= {clamped} (gc-threshold-pct))
    (set-gc-threshold-pct old-pct)
    (test/assert-eq 100 clamped "gc-threshold-pct clamps to maximum 100")
    true
  })

; === Math builtin coverage gaps ===

; Line 2338: non-number type error in math
(test/define "math-non-number-error"
  {do
    (= {result} (error? (+ 1 "two")))
    (test/assert result "math with non-number should error")
    true
  })

; Lines 2347-2348: unary negation
(test/define "math-unary-negation"
  {do
    (test/assert-eq -5 (- 5) "unary minus should negate")
    (test/assert-eq -42 (- 42) "unary minus on larger number")
    true
  })

; === List builtins coverage gaps ===

; Line 2404: len on invalid type
(test/define "len-invalid-type"
  {do
    (= {result} (error? (len 42)))
    (test/assert result "len on number should error")
    true
  })

; Lines 2437-2438: init on empty list
(test/define "init-empty-list"
  {do
    (= {lst} {1})
    (= {result} (init lst))
    (test/assert (== result nil) "init of single-element list returns nil")
    true
  })

; Lines 2447-2452: init on QEXPR vs CONS
(test/define "init-qexpr-preserves-type"
  {do
    (= {lst} {1 2 3})
    (= {result} (init lst))
    (test/assert-eq 2 (len result) "init removes last element")
    (test/assert-eq 1 (nth 1 result) "init first element correct")
    (test/assert-eq 2 (nth 2 result) "init second element correct")
    true
  })

(test/define "init-cons-preserves-type"
  {do
    (= {lst} (list 1 2 3))
    (= {result} (init lst))
    (test/assert-eq 2 (len result) "init on cons removes last element")
    true
  })

; === Parser error paths ===

; Line 1906: Unexpected end of input during parsing
(test/define "read-unterminated-string"
  {do
    (= {result} (error? (read "\"unterminated")))
    (test/assert result "unterminated string should error")
    true
  })

; Line 1914: Error propagation in quote parsing
(test/define "read-quote-error"
  {do
    (= {result} (error? (read "'\"unterminated")))
    (test/assert result "quote of unterminated string should error")
    true
  })

; Line 1924: Error propagation in quasiquote parsing
(test/define "read-quasiquote-error"
  {do
    (= {result} (error? (read "`\"unterminated")))
    (test/assert result "quasiquote of unterminated string should error")
    true
  })

; === Escape sequence coverage ===

; Line 1769: unknown escape returns null char
(test/define "escape-unknown-sequence"
  {do
    ; Test that strings with standard escapes work
    (= {s1} "\t")
    (test/assert-eq 1 (len s1) "tab escape has length 1")
    true
  })

; Lines 1783, 1793-1795: escape sequence output
(test/define "escape-carriage-return"
  {do
    (= {s} "\r")
    (test/assert-eq 1 (len s) "carriage return escape has length 1")
    true
  })

(test/define "escape-quote-in-string"
  {do
    (= {s} "say \"hello\"")
    (test/assert-eq 11 (len s) "string with escaped quotes has correct length")
    true
  })

; === Empty list and continuation paths ===

; Lines 1500-1502: CONT_CTX_WITH empty body returns nil (already tested above)

; Lines 1307-1313: CONT_EVAL_ARGS with no remaining args and thunk
(test/define "eval-args-no-remaining-thunk"
  {do
    ; This tests the path where a function is called with no args but returns a thunk
    (= {f} (\ {} {42}))
    (= {result} (f))
    (test/assert-eq 42 result "no-arg function returns value")
    true
  })

; Lines 1527-1528: Unknown continuation type (defensive, hard to trigger)
; This should never happen in normal operation

; === Env operations coverage ===

; Line 2176: null symbol in env search (defensive check)
(test/define "env-lookup-basic"
  {do
    (= {x} 42)
    (test/assert-eq 42 x "basic env lookup works")
    true
  })

; Lines 2180-2181: trace logging (only with VALK_LOG=trace)
; Lines 2217-2218: debug logging (only with VALK_LOG=debug)
; These require environment variable configuration

; Line 2209: Region promotion path
(test/define "env-put-value-survives"
  {do
    (= {outer} 10)
    (= {f} (\ {x} {+ x outer}))
    (= {result} (f 5))
    (test/assert-eq 15 result "closure captures env values correctly")
    true
  })

; Line 2241: No heap, use thread ctx allocator (rare path)
; This is hard to test without modifying the runtime

; === Coverage builtins (only in VALK_COVERAGE builds) ===
; Lines 5003-5057 are only compiled with VALK_COVERAGE flag
; These are tested by running the coverage build itself

; === THUNK continuation paths ===

; Lines 1553-1555: CONT_THUNK with remaining args
(test/define "thunk-with-remaining-body"
  {do
    ; A function that returns a partial that takes more args
    (= {add3} (\ {a b c} {+ a (+ b c)}))
    (= {partial} (add3 1))
    (= {result} (partial 2 3))
    (test/assert-eq 6 result "thunk partial application works")
    true
  })

; === More list operation coverage ===

(test/define "last-single-element"
  {do
    (= {result} (last {42}))
    (test/assert-eq 42 result "last of single element list")
    true
  })

(test/define "last-multi-element"
  {do
    (= {result} (last {1 2 3 4 5}))
    (test/assert-eq 5 result "last of multi element list")
    true
  })

; === Type predicates ===

(test/define "num-predicate"
  {do
    (test/assert (num? 42) "num? on number returns true")
    (test/assert (not (num? "hello")) "num? on string returns false")
    true
  })

(test/define "str-predicate"
  {do
    (test/assert (str? "hello") "str? on string returns true")
    (test/assert (not (str? 42)) "str? on number returns false")
    true
  })

(test/define "sym-predicate"
  {do
    (test/assert (sym? (quote foo)) "sym? on symbol returns true")
    (test/assert (not (sym? 42)) "sym? on number returns false")
    true
  })

(test/define "fun-predicate"
  {do
    (test/assert (fun? +) "fun? on builtin returns true")
    (test/assert (fun? (\ {x} {x})) "fun? on lambda returns true")
    (test/assert (not (fun? 42)) "fun? on number returns false")
    true
  })

; === penv builtin (lines 2699-2708) ===
(test/define "penv-returns-list"
  {do
    (= {x} 42)
    (= {envlist} (penv))
    (test/assert (list? envlist) "penv returns a list")
    true
  })

(test/define "penv-contains-binding"
  {do
    (= {test-var-unique-12345} 999)
    (= {envlist} (penv))
    ; penv returns list of (sym value) pairs
    (test/assert (> (len envlist) 0) "penv has at least one binding")
    true
  })

; === More GC builtin edge cases ===
(test/define "heap-hard-limit-returns-value"
  {do
    (= {limit} (heap-hard-limit))
    (test/assert (> limit 0) "heap-hard-limit returns positive value")
    true
  })

; === Type coercion and edge cases ===
(test/define "type-builtin-all-types"
  {do
    (test/assert-eq "Number" (type 42) "type of number")
    (test/assert-eq "String" (type "hello") "type of string")
    (test/assert-eq "Q-Expression" (type {1 2 3}) "type of qexpr")
    (test/assert-eq "Symbol" (type (quote foo)) "type of symbol")
    (test/assert-eq "Nil" (type nil) "type of nil")
    (test/assert-eq "Function" (type +) "type of builtin function")
    (test/assert-eq "Function" (type (\ {x} {x})) "type of lambda")
    true
  })

; === Read builtin edge cases ===
(test/define "read-symbol"
  {do
    (= {result} (read "foo"))
    (test/assert (sym? result) "read of symbol returns symbol")
    true
  })

(test/define "read-number"
  {do
    (= {result} (read "42"))
    (test/assert (num? result) "read of number returns number")
    (test/assert-eq 42 result "read number has correct value")
    true
  })

(test/define "read-string"
  {do
    (= {result} (read "\"hello\""))
    (test/assert (str? result) "read of string returns string")
    (test/assert-eq "hello" result "read string has correct value")
    true
  })

(test/define "read-list"
  {do
    (= {result} (read "(1 2 3)"))
    (test/assert (list? result) "read of list returns list")
    (test/assert-eq 3 (len result) "read list has correct length")
    true
  })

(test/define "read-qexpr"
  {do
    (= {result} (read "{1 2 3}"))
    (test/assert (list? result) "read of qexpr returns list")
    (test/assert-eq 3 (len result) "read qexpr has correct length")
    true
  })

; === Join builtin edge cases ===
(test/define "join-empty-lists"
  {do
    (= {result} (join {} {}))
    (test/assert (== result nil) "join of two empty lists is nil")
    true
  })

(test/define "join-with-empty-second"
  {do
    (= {result} (join {1 2} {}))
    (test/assert-eq 2 (len result) "join with empty second")
    true
  })

(test/define "join-with-empty-first"
  {do
    (= {result} (join {} {3 4}))
    (test/assert-eq 2 (len result) "join with empty first")
    true
  })

; === Cons edge cases ===
(test/define "cons-onto-nil"
  {do
    (= {result} (cons 1 nil))
    (test/assert-eq 1 (len result) "cons onto nil creates single-element list")
    (test/assert-eq 1 (head result) "cons onto nil has correct head")
    true
  })

; === Print builtin ===
(test/define "print-number"
  {do
    (= {result} (print 42))
    (test/assert (== result nil) "print returns nil")
    true
  })

(test/define "print-string"
  {do
    (= {result} (print "hello"))
    (test/assert (== result nil) "print string returns nil")
    true
  })

; === Printf edge cases ===
(test/define "printf-basic"
  {do
    (= {result} (printf "value: %d\n" 42))
    (test/assert (== result nil) "printf returns nil")
    true
  })

(test/define "printf-string-format"
  {do
    (= {result} (printf "text: %s\n" "hello"))
    (test/assert (== result nil) "printf with string returns nil")
    true
  })

; === make-string edge cases ===
(test/define "make-string-basic"
  {do
    (= {s} (make-string 5 65))  ; 5 'A' characters
    (test/assert-eq 5 (len s) "make-string creates correct length")
    (test/assert-eq "AAAAA" s "make-string fills with correct char")
    true
  })

(test/define "make-string-zero-length"
  {do
    (= {s} (make-string 0 65))
    (test/assert-eq 0 (len s) "make-string zero length")
    (test/assert-eq "" s "make-string empty")
    true
  })

; === Range edge cases ===
(test/define "range-empty"
  {do
    (= {result} (range 5 5))
    (test/assert (== result nil) "range with equal start/end is empty")
    true
  })

(test/define "range-single"
  {do
    (= {result} (range 0 1))
    (test/assert-eq 1 (len result) "range 0-1 has one element")
    (test/assert-eq 0 (head result) "range starts at 0")
    true
  })

; === Logic short-circuit ===
(test/define "and-short-circuit"
  {do
    (= {called} 0)
    (and 0 (= {called} 1))
    (test/assert-eq 0 called "and short-circuits on false")
    true
  })

(test/define "or-short-circuit"
  {do
    (= {called} 0)
    (or 1 (= {called} 1))
    (test/assert-eq 0 called "or short-circuits on true")
    true
  })

; === Lambda with default args ===
(test/define "lambda-partial-application"
  {do
    (= {add} (\ {a b} {+ a b}))
    (= {add5} (add 5))
    (= {result} (add5 3))
    (test/assert-eq 8 result "partial application works")
    true
  })

; === Eval on symbols ===
(test/define "eval-symbol-lookup"
  {do
    (= {x} 42)
    (= {result} (eval (quote x)))
    (test/assert-eq 42 result "eval looks up symbol in env")
    true
  })

; === Nested do blocks ===
(test/define "nested-do-returns-last"
  {do
    (= {result} (do
                  1
                  (do 2 3)
                  4))
    (test/assert-eq 4 result "nested do returns outermost last")
    true
  })

; === Error handling ===
(test/define "error-returns-error"
  {do
    (= {err} (error "test error"))
    (test/assert (error? err) "error returns error value")
    true
  })

(test/define "error-message-preserved"
  {do
    ; Create and test error
    (= {result} (error? (/ 1 0)))
    (test/assert result "division by zero creates error")
    true
  })

; === Multiple definitions ===
(test/define "def-multiple-values"
  {do
    (def {a b c} 1 2 3)
    (test/assert-eq 1 a "first def value")
    (test/assert-eq 2 b "second def value")
    (test/assert-eq 3 c "third def value")
    true
  })

; === Variadic builtins ===
(test/define "plus-variadic"
  {do
    (test/assert-eq 15 (+ 1 2 3 4 5) "variadic plus")
    (test/assert-eq 0 (+) "plus with no args")
    true
  })

(test/define "mul-variadic"
  {do
    (test/assert-eq 120 (* 1 2 3 4 5) "variadic multiply")
    (test/assert-eq 1 (*) "multiply with no args")
    true
  })

(test/define "min-variadic"
  {do
    (test/assert-eq 1 (min 3 1 4 1 5) "variadic min")
    true
  })

(test/define "max-variadic"
  {do
    (test/assert-eq 5 (max 3 1 4 1 5) "variadic max")
    true
  })

; === String operations ===
(test/define "str-concat"
  {do
    (= {result} (str/concat "hello" " " "world"))
    (test/assert-eq "hello world" result "string concatenation")
    true
  })

(test/define "str-nth"
  {do
    (= {result} (str/nth "hello" 0))
    (test/assert-eq "h" result "str/nth gets first char")
    true
  })

(test/define "str-nth-last"
  {do
    (= {result} (str/nth "hello" 4))
    (test/assert-eq "o" result "str/nth gets last char")
    true
  })

; === Comparison chains ===
(test/define "equality-chain"
  {do
    (test/assert (== 1 1 1 1) "all equal")
    (test/assert (not (== 1 1 2 1)) "not all equal")
    true
  })

(test/define "less-than-chain"
  {do
    (test/assert (< 1 2 3 4) "strictly increasing")
    (test/assert (not (< 1 2 2 3)) "not strictly increasing with equal")
    true
  })

(test/define "greater-than-chain"
  {do
    (test/assert (> 4 3 2 1) "strictly decreasing")
    (test/assert (not (> 4 3 3 1)) "not strictly decreasing with equal")
    true
  })

(test/run)
