; Test suite for low-level aio/* builtins in aio_uv.c
; Tests: aio/pure, aio/fail, aio/then, aio/catch, aio/finally, 
;        aio/all, aio/race, aio/any, aio/cancel, aio/cancelled?, aio/status
;        aio/sleep, aio/let, aio/do, aio/bracket, aio/scope, aio/on-cancel

(load "src/prelude.valk")
(load "src/modules/test.valk")

; ============================================================================
; aio/pure - create immediately completed handle
; ============================================================================

; ============================================================================
; aio/fail - create immediately failed handle
; ============================================================================

; ============================================================================
; aio/status - get handle status
; ============================================================================

; ============================================================================
; aio/cancelled? - check if cancelled
; ============================================================================

; ============================================================================
; aio/cancel - request cancellation
; ============================================================================

; ============================================================================
; aio/then - chain handles
; ============================================================================

; ============================================================================
; aio/catch - handle errors
; ============================================================================

; ============================================================================
; aio/finally - cleanup after completion or failure
; ============================================================================

; ============================================================================
; aio/all - wait for all handles
; ============================================================================

; ============================================================================
; aio/race - first to complete wins
; ============================================================================

; ============================================================================
; aio/any - first success wins
; ============================================================================

; ============================================================================
; aio/on-cancel - register cancellation handler
; ============================================================================

; ============================================================================
; aio/bracket - resource safety
; ============================================================================

; ============================================================================
; aio/scope - structured concurrency
; ============================================================================

; ============================================================================
; aio/let - parallel bindings
; ============================================================================

; ============================================================================
; aio/do - sequential composition with bind syntax
; ============================================================================

; ============================================================================
; Chaining tests
; ============================================================================

; ============================================================================
; Argument validation error tests
; ============================================================================

; ============================================================================
; aio/sleep - timed delay (requires AIO system)
; ============================================================================

; ============================================================================
; aio/schedule - schedule a callback
; ============================================================================

; ============================================================================
; aio/pool-stats - get pool statistics
; ============================================================================

; ============================================================================
; Error handling edge cases
; ============================================================================

; Run all tests
(test/run (list
  (test "aio/pure creates completed handle with value"
    {do
    (= {h} (aio/pure 42))
    (== (aio/status h) :completed)
  })
  (test "aio/pure with nil value"
    {do
    (= {h} (aio/pure nil))
    (== (aio/status h) :completed)
  })
  (test "aio/pure with list value"
    {do
    (= {h} (aio/pure (list 1 2 3)))
    (== (aio/status h) :completed)
  })
  (test "aio/fail creates failed handle"
    {do
    (= {h} (aio/fail "test error"))
    (== (aio/status h) :failed)
  })
  (test "aio/fail with symbol error"
    {do
    (= {h} (aio/fail :error))
    (== (aio/status h) :failed)
  })
  (test "aio/status on completed handle"
    {do
    (= {h} (aio/pure 1))
    (== (aio/status h) :completed)
  })
  (test "aio/status on failed handle"
    {do
    (= {h} (aio/fail "err"))
    (== (aio/status h) :failed)
  })
  (test "aio/cancelled? on completed handle returns false"
    {do
    (= {h} (aio/pure 1))
    (== (aio/cancelled? h) :false)
  })
  (test "aio/cancelled? on failed handle returns false"
    {do
    (= {h} (aio/fail "err"))
    (== (aio/cancelled? h) :false)
  })
  (test "aio/cancel on completed handle returns false"
    {do
    (= {h} (aio/pure 1))
    (== (aio/cancel h) :false)
  })
  (test "aio/cancel on failed handle returns false"
    {do
    (= {h} (aio/fail "err"))
    (== (aio/cancel h) :false)
  })
  (test "aio/then on completed handle runs transform"
    {do
    (= {h} (aio/pure 10))
    (= {h2} (aio/then h (\ {x} {(aio/pure (* x 2))})))
    (== (aio/status h2) :completed)
  })
  (test "aio/then on failed handle propagates failure"
    {do
    (= {h} (aio/fail "error"))
    (= {h2} (aio/then h (\ {x} {(aio/pure (* x 2))})))
    (== (aio/status h2) :failed)
  })
  (test "aio/then transform that returns non-handle"
    {do
    (= {h} (aio/pure 5))
    (= {h2} (aio/then h (\ {x} {(* x 3)})))
    (== (aio/status h2) :completed)
  })
  (test "aio/then transform that returns failed handle"
    {do
    (= {h} (aio/pure 5))
    (= {h2} (aio/then h (\ {x} {(aio/fail "transform failed")})))
    (== (aio/status h2) :failed)
  })
  (test "aio/catch on completed handle passes through"
    {do
    (= {h} (aio/pure 42))
    (= {h2} (aio/catch h (\ {err} {(aio/pure 0)})))
    (== (aio/status h2) :completed)
  })
  (test "aio/catch on failed handle runs recovery"
    {do
    (= {h} (aio/fail "error"))
    (= {h2} (aio/catch h (\ {err} {(aio/pure 99)})))
    (== (aio/status h2) :completed)
  })
  (test "aio/catch recovery that returns failed handle propagates failure"
    {do
    (= {h} (aio/fail "error"))
    (= {h2} (aio/catch h (\ {err} {(aio/fail "recovery also failed")})))
    (== (aio/status h2) :failed)
  })
  (test "aio/finally on completed handle"
    {do
    (= {h} (aio/pure 42))
    (= {cleanup-ran} false)
    (= {h2} (aio/finally h (\ {} {(= {cleanup-ran} true) nil})))
    (== (aio/status h2) :completed)
  })
  (test "aio/finally on failed handle"
    {do
    (= {h} (aio/fail "error"))
    (= {h2} (aio/finally h (\ {} {nil})))
    (== (aio/status h2) :failed)
  })
  (test "aio/all with empty list"
    {do
    (= {h} (aio/all ()))
    (== (aio/status h) :completed)
  })
  (test "aio/all with single completed handle"
    {do
    (= {h} (aio/all (list (aio/pure 1))))
    (== (aio/status h) :completed)
  })
  (test "aio/all with multiple completed handles"
    {do
    (= {h} (aio/all (list (aio/pure 1) (aio/pure 2) (aio/pure 3))))
    (== (aio/status h) :completed)
  })
  (test "aio/all with one failed handle fails"
    {do
    (= {h} (aio/all (list (aio/pure 1) (aio/fail "error") (aio/pure 3))))
    (== (aio/status h) :failed)
  })
  (test "aio/all with all failed handles"
    {do
    (= {h} (aio/all (list (aio/fail "e1") (aio/fail "e2"))))
    (== (aio/status h) :failed)
  })
  (test "aio/race with empty list returns error"
    {do
    (= {result} (aio/race ()))
    (error? result)
  })
  (test "aio/race with single completed handle"
    {do
    (= {h} (aio/race (list (aio/pure 42))))
    (== (aio/status h) :completed)
  })
  (test "aio/race with multiple completed handles"
    {do
    (= {h} (aio/race (list (aio/pure 1) (aio/pure 2) (aio/pure 3))))
    (== (aio/status h) :completed)
  })
  (test "aio/race with first failed"
    {do
    (= {h} (aio/race (list (aio/fail "error") (aio/pure 2))))
    (== (aio/status h) :failed)
  })
  (test "aio/any with single completed handle"
    {do
    (= {h} (aio/any (list (aio/pure 42))))
    (== (aio/status h) :completed)
  })
  (test "aio/any with mixed handles (one success)"
    {do
    (= {h} (aio/any (list (aio/fail "e1") (aio/pure 42) (aio/fail "e2"))))
    (== (aio/status h) :completed)
  })
  (test "aio/any with all failed handles"
    {do
    (= {h} (aio/any (list (aio/fail "e1") (aio/fail "e2") (aio/fail "e3"))))
    (== (aio/status h) :failed)
  })
  (test "aio/on-cancel on completed handle"
    {do
    (= {h} (aio/pure 42))
    (= {h2} (aio/on-cancel h (\ {} {nil})))
    (== (aio/status h2) :completed)
  })
  (test "aio/on-cancel on failed handle"
    {do
    (= {h} (aio/fail "error"))
    (= {h2} (aio/on-cancel h (\ {} {nil})))
    (== (aio/status h2) :failed)
  })
  (test "aio/bracket with successful use"
    {do
    (= {h} (aio/bracket 
      (aio/pure "resource")
      (\ {r} {(aio/pure nil)})
      (\ {r} {(aio/pure 42)})))
    (== (aio/status h) :completed)
  })
  (test "aio/bracket with failed use"
    {do
    (= {h} (aio/bracket 
      (aio/pure "resource")
      (\ {r} {(aio/pure nil)})
      (\ {r} {(aio/fail "use failed")})))
    (== (aio/status h) :failed)
  })
  (test "aio/scope with immediate return fails"
    {do
    (= {h} (aio/scope (\ {} {42})))
    (== (aio/status h) :failed)
  })
  (test "aio/scope with pure handle fails without loop"
    {do
    (= {h} (aio/scope (\ {} {(aio/pure 99)})))
    (== (aio/status h) :failed)
  })
  (test "aio/scope with failed handle"
    {do
    (= {h} (aio/scope (\ {} {(aio/fail "scope failed")})))
    (== (aio/status h) :failed)
  })
  (test "aio/let with single binding"
    {do
    (= {h} (aio/let ((x (aio/pure 10))) x))
    (== (aio/status h) :completed)
  })
  (test "aio/let with multiple bindings"
    {do
    (= {h} (aio/let ((a (aio/pure 1)) (b (aio/pure 2))) (+ a b)))
    (== (aio/status h) :completed)
  })
  (test "aio/let with then barrier"
    {do
    (= {h} (aio/let ((x (aio/pure 10)) :then (y (aio/pure (* x 2)))) y))
    (== (aio/status h) :completed)
  })
  (test "aio/do with single expression"
    {do
    (= {h} (aio/do {(aio/pure 42)}))
    (== (aio/status h) :completed)
  })
  (test "aio/do with multiple expressions"
    {do
    (= {h} (aio/do {
      (aio/pure 1)
      (aio/pure 2)
      (aio/pure 3)}))
    (== (aio/status h) :completed)
  })
  (test "aio/do with binding and expression"
    {do
    (= {h} (aio/do {
      (x <- (aio/pure 10))
      (aio/pure (* x 2))}))
    (== (aio/status h) :completed)
  })
  (test "aio/do with failure returns completed"
    {do
    (= {h} (aio/do {
      (aio/pure 1)
      (aio/fail "middle failed")
      (aio/pure 3)}))
    (== (aio/status h) :completed)
  })
  (test "multiple then chains"
    {do
    (= {h} (aio/pure 1))
    (= {h2} (aio/then h (\ {x} {(aio/pure (+ x 1))})))
    (= {h3} (aio/then h2 (\ {x} {(aio/pure (+ x 1))})))
    (= {h4} (aio/then h3 (\ {x} {(aio/pure (+ x 1))})))
    (== (aio/status h4) :completed)
  })
  (test "catch after then chain"
    {do
    (= {h} (aio/pure 1))
    (= {h2} (aio/then h (\ {x} {(aio/fail "mid-chain error")})))
    (= {h3} (aio/catch h2 (\ {e} {(aio/pure 0)})))
    (== (aio/status h3) :completed)
  })
  (test "finally after catch"
    {do
    (= {h} (aio/fail "initial error"))
    (= {h2} (aio/catch h (\ {e} {(aio/pure "recovered")})))
    (= {h3} (aio/finally h2 (\ {} {nil})))
    (== (aio/status h3) :completed)
  })
  (test "aio/pure with no args returns error"
    {do
    (= {result} (aio/pure))
    (error? result)
  })
  (test "aio/fail with no args returns error"
    {do
    (= {result} (aio/fail))
    (error? result)
  })
  (test "aio/then with no args returns error"
    {do
    (= {result} (aio/then))
    (error? result)
  })
  (test "aio/then with one arg returns error"
    {do
    (= {result} (aio/then (aio/pure 1)))
    (error? result)
  })
  (test "aio/then with non-handle first arg returns error"
    {do
    (= {result} (aio/then 42 (\ {x} {x})))
    (error? result)
  })
  (test "aio/then with non-function second arg returns error"
    {do
    (= {result} (aio/then (aio/pure 1) 42))
    (error? result)
  })
  (test "aio/catch with wrong args returns error"
    {do
    (= {result} (aio/catch 42 (\ {x} {x})))
    (error? result)
  })
  (test "aio/finally with wrong args returns error"
    {do
    (= {result} (aio/finally 42 (\ {} {nil})))
    (error? result)
  })
  (test "aio/all with non-list returns error"
    {do
    (= {result} (aio/all 42))
    (error? result)
  })
  (test "aio/race with non-list returns error"
    {do
    (= {result} (aio/race 42))
    (error? result)
  })
  (test "aio/race with empty list returns error"
    {do
    (= {result} (aio/race ()))
    (error? result)
  })
  (test "aio/any with empty list returns error"
    {do
    (= {result} (aio/any ()))
    (error? result)
  })
  (test "aio/status with no args returns error"
    {do
    (= {result} (aio/status))
    (error? result)
  })
  (test "aio/status with non-handle returns error"
    {do
    (= {result} (aio/status 42))
    (error? result)
  })
  (test "aio/cancel with no args returns error"
    {do
    (= {result} (aio/cancel))
    (error? result)
  })
  (test "aio/cancelled? with no args returns error"
    {do
    (= {result} (aio/cancelled?))
    (error? result)
  })
  (test "aio/bracket with wrong args returns error"
    {do
    (= {result} (aio/bracket 42 (\ {r} {nil}) (\ {r} {nil})))
    (error? result)
  })
  (test "aio/scope with non-function returns error"
    {do
    (= {result} (aio/scope 42))
    (error? result)
  })
  (test "aio/on-cancel with wrong args returns error"
    {do
    (= {result} (aio/on-cancel 42 (\ {} {nil})))
    (error? result)
  })
  (test "aio/let with no bindings works"
    {do
    (= {result} (aio/let {} {42}))
    (== (aio/status result) :completed)
  })
  (test "aio/do with number returns error"
    {do
    (= {result} (aio/do 42))
    (error? result)
  })
  (test "aio/sleep creates handle"
    {do
    (= {sys} (aio/await (aio/start)))
    (test/assert (not (== sys nil)) "aio/start should succeed")
    (= {h} (aio/sleep sys 1))
    (= {status} (aio/status h))
    (= {__result} (or (or (== status :pending) (== status :running))
        (or (== status :completed) (== status :cancelled))))
    (aio/await (aio/stop sys))
    __result
  })
  (test "aio/sleep with zero delay"
    {do
    (= {sys} (aio/await (aio/start)))
    (= {h} (aio/sleep sys 0))
    (aio/await (aio/stop sys))
    true
  })
  (test "aio/schedule runs callback"
    {do
    (= {sys} (aio/await (aio/start)))
    (test/assert (not (== sys nil)) "aio/start should succeed")
    (= {result} (aio/schedule sys 1 (\ {} {42})))
    (aio/await (aio/stop sys))
    true
  })
  (test "aio/schedule with zero delay"
    {do
    (= {sys} (aio/await (aio/start)))
    (= {result} (aio/schedule sys 0 (\ {} {"immediate"})))
    (aio/await (aio/stop sys))
    true
  })
  (test "aio/pool-stats returns stats"
    {do
    (= {sys} (aio/await (aio/start)))
    (= {stats} (aio/pool-stats sys))
    (= {__result} (not (== stats nil)))
    (aio/await (aio/stop sys))
    __result
  })
  (test "aio/then with nil function result"
    {do
    (= {h} (aio/pure 1))
    (= {h2} (aio/then h (\ {x} {nil})))
    (== (aio/status h2) :completed)
  })
  (test "aio/catch that re-raises propagates failure"
    {do
    (= {h} (aio/fail "error1"))
    (= {h2} (aio/catch h (\ {e} {(aio/fail "error2")})))
    (== (aio/status h2) :failed)
  })
  (test "nested aio/all"
    {do
    (= {inner1} (aio/all (list (aio/pure 1) (aio/pure 2))))
    (= {inner2} (aio/all (list (aio/pure 3) (aio/pure 4))))
    (= {outer} (aio/all (list inner1 inner2)))
    (== (aio/status outer) :completed)
  })
  (test "nested aio/race"
    {do
    (= {inner1} (aio/race (list (aio/pure 1) (aio/pure 2))))
    (= {inner2} (aio/race (list (aio/pure 3) (aio/pure 4))))
    (= {outer} (aio/race (list inner1 inner2)))
    (== (aio/status outer) :completed)
  })
   (test "aio/any with mix of success and failure"
     {do
     (= {h} (aio/any (list (aio/fail "e1") (aio/fail "e2") (aio/pure 42) (aio/fail "e3"))))
     (== (aio/status h) :completed)
   })
   (test "aio/never creates running handle that never completes"
     {do
     (= {sys} (aio/await (aio/start)))
     (test/assert (not (== sys nil)) "aio/start should succeed")
      (= {h} (aio/never sys))
      (= {status} (aio/status h))
      (= {__result} (== status :running))
      (aio/await (aio/stop sys))
      __result
    })
   (test "aio/never can be cancelled"
     {do
     (= {sys} (aio/await (aio/start)))
      (= {h} (aio/never sys))
      (= {cancelled} (aio/cancel h))
      (= {__result} (== cancelled :true))
      (aio/await (aio/stop sys))
      __result
    })
    (test "aio/on-loop-thread? returns false from main thread"
     {do
     (= {sys} (aio/await (aio/start)))
      (= {result} (aio/on-loop-thread? sys))
      (= {__result} (== result 0))
      (aio/await (aio/stop sys))
      __result
    })
   (test "aio/metrics-json-compact returns JSON string"
     {do
     (= {sys} (aio/await (aio/start)))
      (= {json} (aio/metrics-json-compact sys))
      (= {__result} (> (len json) 2))
      (aio/await (aio/stop sys))
      __result
    })
   (test "aio/systems-json returns JSON array string"
     {do
     (= {sys} (aio/await (aio/start)))
      (= {json} (aio/systems-json sys))
      (= {__result} (== (str/slice json 0 1) "["))
      (aio/await (aio/stop sys))
      __result
    })
   (test "aio/never in race with immediate value"
      {do
      (= {sys} (aio/await (aio/start)))
      (= {never-handle} (aio/never sys))
      (= {immediate-handle} (aio/pure 42))
       (= {race-result} (aio/race (list never-handle immediate-handle)))
       (= {__result} (== (aio/status race-result) :completed))
       (aio/await (aio/stop sys))
       __result
     })

    ; ============================================================================
    ; aio/then - transform error path (fn returns error)
    ; ============================================================================
    (test "aio/then transform that returns error"
      {do
      (= {h} (aio/pure 5))
      (= {h2} (aio/then h (\ {x} {(error "transform error")})))
      (== (aio/status h2) :failed)
    })

    ; ============================================================================
    ; aio/catch - recovery returns non-handle value
    ; ============================================================================
    (test "aio/catch recovery returns plain value"
      {do
      (= {h} (aio/fail "error"))
      (= {h2} (aio/catch h (\ {err} {42})))
      (== (aio/status h2) :completed)
    })
    (test "aio/catch recovery returns error"
      {do
      (= {h} (aio/fail "error"))
      (= {h2} (aio/catch h (\ {err} {(error "recovery error")})))
      (== (aio/status h2) :failed)
    })

    ; ============================================================================
    ; aio/result - extract result from completed handle
    ; ============================================================================
    (test "aio/result on completed handle"
      {do
      (= {h} (aio/pure 42))
      (== (aio/result h) 42)
    })
    (test "aio/result on failed handle returns error"
      {do
      (= {result} (aio/result (aio/fail "oops")))
      (error? result)
    })
    (test "aio/result with string value"
      {do
      (= {h} (aio/pure "hello"))
      (== (aio/result h) "hello")
    })

    (test "aio/result with no args returns error"
      {do
      (= {result} (aio/result))
      (error? result)
    })
    (test "aio/result with non-handle returns error"
      {do
      (= {result} (aio/result 42))
      (error? result)
    })

    ; ============================================================================
    ; aio/error - extract error from failed handle
    ; ============================================================================
    (test "aio/error on failed handle"
      {do
      (= {h} (aio/fail "bad"))
      (== (aio/error h) "bad")
    })
    (test "aio/error on completed handle returns error"
      {do
      (= {result} (aio/error (aio/pure 42)))
      (error? result)
    })
    (test "aio/error with symbol error"
      {do
      (= {h} (aio/fail :timeout))
      (== (aio/error h) :timeout)
    })
    (test "aio/error with no args returns error"
      {do
      (= {result} (aio/error))
      (error? result)
    })
    (test "aio/error with non-handle returns error"
      {do
      (= {result} (aio/error 42))
      (error? result)
    }))
    {:suite-name "AIO Builtins Coverage Tests"})
