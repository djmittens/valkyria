; Test suite for low-level aio/* builtins in aio_uv.c
; Tests: aio/pure, aio/fail, aio/then, aio/catch, aio/finally, 
;        aio/all, aio/race, aio/any, aio/cancel, aio/cancelled?, aio/status
;        aio/sleep, aio/let, aio/do, aio/bracket, aio/scope, aio/on-cancel

(load "src/prelude.valk")
(load "src/modules/test.valk")

(test/suite "AIO Builtins Coverage Tests")

; ============================================================================
; aio/pure - create immediately completed handle
; ============================================================================

(test/define "aio/pure creates completed handle with value"
  {do
    (def {h} (aio/pure 42))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/pure with nil value"
  {do
    (def {h} (aio/pure nil))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/pure with list value"
  {do
    (def {h} (aio/pure (list 1 2 3)))
    (== (aio/status h) (quote :completed))
  })

; ============================================================================
; aio/fail - create immediately failed handle
; ============================================================================

(test/define "aio/fail creates failed handle"
  {do
    (def {h} (aio/fail "test error"))
    (== (aio/status h) (quote :failed))
  })

(test/define "aio/fail with symbol error"
  {do
    (def {h} (aio/fail (quote :error)))
    (== (aio/status h) (quote :failed))
  })

; ============================================================================
; aio/status - get handle status
; ============================================================================

(test/define "aio/status on completed handle"
  {do
    (def {h} (aio/pure 1))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/status on failed handle"
  {do
    (def {h} (aio/fail "err"))
    (== (aio/status h) (quote :failed))
  })

; ============================================================================
; aio/cancelled? - check if cancelled
; ============================================================================

(test/define "aio/cancelled? on completed handle returns false"
  {do
    (def {h} (aio/pure 1))
    (== (aio/cancelled? h) (quote :false))
  })

(test/define "aio/cancelled? on failed handle returns false"
  {do
    (def {h} (aio/fail "err"))
    (== (aio/cancelled? h) (quote :false))
  })

; ============================================================================
; aio/cancel - request cancellation
; ============================================================================

(test/define "aio/cancel on completed handle returns false"
  {do
    (def {h} (aio/pure 1))
    (== (aio/cancel h) (quote :false))
  })

(test/define "aio/cancel on failed handle returns false"
  {do
    (def {h} (aio/fail "err"))
    (== (aio/cancel h) (quote :false))
  })

; ============================================================================
; aio/then - chain handles
; ============================================================================

(test/define "aio/then on completed handle runs transform"
  {do
    (def {h} (aio/pure 10))
    (def {h2} (aio/then h (\ {x} {(aio/pure (* x 2))})))
    (== (aio/status h2) (quote :completed))
  })

(test/define "aio/then on failed handle propagates failure"
  {do
    (def {h} (aio/fail "error"))
    (def {h2} (aio/then h (\ {x} {(aio/pure (* x 2))})))
    (== (aio/status h2) (quote :failed))
  })

(test/define "aio/then transform that returns non-handle"
  {do
    (def {h} (aio/pure 5))
    (def {h2} (aio/then h (\ {x} {(* x 3)})))
    (== (aio/status h2) (quote :completed))
  })

(test/define "aio/then transform that returns failed handle"
  {do
    (def {h} (aio/pure 5))
    (def {h2} (aio/then h (\ {x} {(aio/fail "transform failed")})))
    (== (aio/status h2) (quote :failed))
  })

; ============================================================================
; aio/catch - handle errors
; ============================================================================

(test/define "aio/catch on completed handle passes through"
  {do
    (def {h} (aio/pure 42))
    (def {h2} (aio/catch h (\ {err} {(aio/pure 0)})))
    (== (aio/status h2) (quote :completed))
  })

(test/define "aio/catch on failed handle runs recovery"
  {do
    (def {h} (aio/fail "error"))
    (def {h2} (aio/catch h (\ {err} {(aio/pure 99)})))
    (== (aio/status h2) (quote :completed))
  })

(test/define "aio/catch recovery that returns failed handle"
  {do
    (def {h} (aio/fail "error"))
    (def {h2} (aio/catch h (\ {err} {(aio/fail "recovery also failed")})))
    (== (aio/status h2) (quote :completed))
  })

; ============================================================================
; aio/finally - cleanup after completion or failure
; ============================================================================

(test/define "aio/finally on completed handle"
  {do
    (def {h} (aio/pure 42))
    (def {cleanup-ran} false)
    (def {h2} (aio/finally h (\ {} {(def {cleanup-ran} true) nil})))
    (== (aio/status h2) (quote :completed))
  })

(test/define "aio/finally on failed handle"
  {do
    (def {h} (aio/fail "error"))
    (def {h2} (aio/finally h (\ {} {nil})))
    (== (aio/status h2) (quote :failed))
  })

; ============================================================================
; aio/all - wait for all handles
; ============================================================================

(test/define "aio/all with empty list"
  {do
    (def {h} (aio/all ()))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/all with single completed handle"
  {do
    (def {h} (aio/all (list (aio/pure 1))))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/all with multiple completed handles"
  {do
    (def {h} (aio/all (list (aio/pure 1) (aio/pure 2) (aio/pure 3))))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/all with one failed handle fails"
  {do
    (def {h} (aio/all (list (aio/pure 1) (aio/fail "error") (aio/pure 3))))
    (== (aio/status h) (quote :failed))
  })

(test/define "aio/all with all failed handles"
  {do
    (def {h} (aio/all (list (aio/fail "e1") (aio/fail "e2"))))
    (== (aio/status h) (quote :failed))
  })

; ============================================================================
; aio/race - first to complete wins
; ============================================================================

(test/define "aio/race with empty list returns error"
  {do
    (def {result} (aio/race ()))
    (error? result)
  })

(test/define "aio/race with single completed handle"
  {do
    (def {h} (aio/race (list (aio/pure 42))))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/race with multiple completed handles"
  {do
    (def {h} (aio/race (list (aio/pure 1) (aio/pure 2) (aio/pure 3))))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/race with first failed"
  {do
    (def {h} (aio/race (list (aio/fail "error") (aio/pure 2))))
    (== (aio/status h) (quote :failed))
  })

; ============================================================================
; aio/any - first success wins
; ============================================================================

(test/define "aio/any with empty list"
  {do
    (def {h} (aio/any ()))
    (== (aio/status h) (quote :failed))
  })

(test/define "aio/any with single completed handle"
  {do
    (def {h} (aio/any (list (aio/pure 42))))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/any with mixed handles (one success)"
  {do
    (def {h} (aio/any (list (aio/fail "e1") (aio/pure 42) (aio/fail "e2"))))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/any with all failed handles"
  {do
    (def {h} (aio/any (list (aio/fail "e1") (aio/fail "e2") (aio/fail "e3"))))
    (== (aio/status h) (quote :failed))
  })

; ============================================================================
; aio/on-cancel - register cancellation handler
; ============================================================================

(test/define "aio/on-cancel on completed handle"
  {do
    (def {h} (aio/pure 42))
    (def {h2} (aio/on-cancel h (\ {} {nil})))
    (== (aio/status h2) (quote :completed))
  })

(test/define "aio/on-cancel on failed handle"
  {do
    (def {h} (aio/fail "error"))
    (def {h2} (aio/on-cancel h (\ {} {nil})))
    (== (aio/status h2) (quote :failed))
  })

; ============================================================================
; aio/bracket - resource safety
; ============================================================================

(test/define "aio/bracket with successful use"
  {do
    (def {h} (aio/bracket 
      (aio/pure "resource")
      (\ {r} {(aio/pure nil)})
      (\ {r} {(aio/pure 42)})))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/bracket with failed use"
  {do
    (def {h} (aio/bracket 
      (aio/pure "resource")
      (\ {r} {(aio/pure nil)})
      (\ {r} {(aio/fail "use failed")})))
    (== (aio/status h) (quote :failed))
  })

; ============================================================================
; aio/scope - structured concurrency
; ============================================================================

(test/define "aio/scope with immediate return fails"
  {do
    (def {h} (aio/scope (\ {} {42})))
    (== (aio/status h) (quote :failed))
  })

(test/define "aio/scope with pure handle fails without loop"
  {do
    (def {h} (aio/scope (\ {} {(aio/pure 99)})))
    (== (aio/status h) (quote :failed))
  })

(test/define "aio/scope with failed handle"
  {do
    (def {h} (aio/scope (\ {} {(aio/fail "scope failed")})))
    (== (aio/status h) (quote :failed))
  })

; ============================================================================
; aio/let - parallel bindings
; ============================================================================

(test/define "aio/let with single binding"
  {do
    (def {h} (aio/let ((x (aio/pure 10))) x))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/let with multiple bindings"
  {do
    (def {h} (aio/let ((a (aio/pure 1)) (b (aio/pure 2))) (+ a b)))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/let with then barrier"
  {do
    (def {h} (aio/let ((x (aio/pure 10)) (quote :then) (y (aio/pure (* x 2)))) y))
    (== (aio/status h) (quote :completed))
  })

; ============================================================================
; aio/do - sequential composition with bind syntax
; ============================================================================

(test/define "aio/do with single expression"
  {do
    (def {h} (aio/do {(aio/pure 42)}))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/do with multiple expressions"
  {do
    (def {h} (aio/do {
      (aio/pure 1)
      (aio/pure 2)
      (aio/pure 3)}))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/do with binding and expression"
  {do
    (def {h} (aio/do {
      (x <- (aio/pure 10))
      (aio/pure (* x 2))}))
    (== (aio/status h) (quote :completed))
  })

(test/define "aio/do with failure returns completed"
  {do
    (def {h} (aio/do {
      (aio/pure 1)
      (aio/fail "middle failed")
      (aio/pure 3)}))
    (== (aio/status h) (quote :completed))
  })

; ============================================================================
; Chaining tests
; ============================================================================

(test/define "multiple then chains"
  {do
    (def {h} (aio/pure 1))
    (def {h2} (aio/then h (\ {x} {(aio/pure (+ x 1))})))
    (def {h3} (aio/then h2 (\ {x} {(aio/pure (+ x 1))})))
    (def {h4} (aio/then h3 (\ {x} {(aio/pure (+ x 1))})))
    (== (aio/status h4) (quote :completed))
  })

(test/define "catch after then chain"
  {do
    (def {h} (aio/pure 1))
    (def {h2} (aio/then h (\ {x} {(aio/fail "mid-chain error")})))
    (def {h3} (aio/catch h2 (\ {e} {(aio/pure 0)})))
    (== (aio/status h3) (quote :completed))
  })

(test/define "finally after catch"
  {do
    (def {h} (aio/fail "initial error"))
    (def {h2} (aio/catch h (\ {e} {(aio/pure "recovered")})))
    (def {h3} (aio/finally h2 (\ {} {nil})))
    (== (aio/status h3) (quote :completed))
  })

; Run all tests
(test/run {})
