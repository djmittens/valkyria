; Test suite for sequential-map function in src/async_handles.valk
; This tests the sequential-map function (lines 134-143) which applies
; an async function to each item in a list sequentially.

(load "src/prelude.valk")
(load "src/modules/test.valk")
(load "src/async_handles.valk")

(def {aio} (aio/start))

; ============================================================================
; Basic Functionality Tests
; ============================================================================

; ============================================================================
; Sequential Execution Order Tests
; ============================================================================

; ============================================================================
; Transform Function Tests
; ============================================================================

; ============================================================================
; Test with delayed async operations
; ============================================================================

; ============================================================================
; Result Type Tests
; ============================================================================

; ============================================================================
; Edge Cases
; ============================================================================

; ============================================================================
; Run all tests
; ============================================================================

(test/run-async aio (list
  (test-async "sequential-map with empty list returns empty list" (\ {} {
    (def {result-handle} (sequential-map (\ {x} {(aio/pure (* x 2))}) ()))
    (aio/then result-handle (\ {result} {
      (== result ())
    }))
  }))
  (test-async "sequential-map with single element" (\ {} {
    (def {result-handle} (sequential-map (\ {x} {(aio/pure (* x 10))}) (list 5)))
    (aio/then result-handle (\ {result} {
      (== (head result) 50)
    }))
  }))
  (test-async "sequential-map with multiple elements" (\ {} {
    (def {result-handle} (sequential-map (\ {x} {(aio/pure (* x 2))}) (list 1 2 3)))
    (aio/then result-handle (\ {result} {
      ; Result should be (2 4 6)
      (def {first} (head result))
      (def {rest1} (tail result))
      (def {second} (head rest1))
      (def {rest2} (tail rest1))
      (def {third} (head rest2))
      (and (== first 2) (and (== second 4) (== third 6)))
    }))
  }))
  (test-async "sequential-map executes in order" (\ {} {
    ; We'll track the order items are processed
    (def {order} ())
    (def {track-and-double} (\ {x} {
      (def {order} (join order (list x)))
      (aio/pure (* x 2))
    }))
    
    (def {result-handle} (sequential-map track-and-double (list 1 2 3 4)))
    (aio/then result-handle (\ {result} {
      ; Order should be (1 2 3 4) - items processed in sequence
      (def {o1} (head order))
      (def {o2} (head (tail order)))
      (def {o3} (head (tail (tail order))))
      (def {o4} (head (tail (tail (tail order)))))
      (and (== o1 1) (and (== o2 2) (and (== o3 3) (== o4 4))))
    }))
  }))
  (test-async "sequential-map with identity transform" (\ {} {
    (def {result-handle} (sequential-map (\ {x} {(aio/pure x)}) (list 10 20 30)))
    (aio/then result-handle (\ {result} {
      (def {first} (head result))
      (def {second} (head (tail result)))
      (def {third} (head (tail (tail result))))
      (and (== first 10) (and (== second 20) (== third 30)))
    }))
  }))
  (test-async "sequential-map with constant transform" (\ {} {
    (def {to-const} (\ {x} {(aio/pure "constant")}))
    (def {result-handle} (sequential-map to-const (list 1 2)))
    (aio/then result-handle (\ {result} {
      (def {first} (head result))
      (def {second} (head (tail result)))
      (and (== first "constant") (== second "constant"))
    }))
  }))
  (test-async "sequential-map with delayed operations" (\ {} {
    ; Each operation takes a small delay
    (def {delayed-double} (\ {x} {
      (aio/then (aio/sleep aio 5) (\ {_} {(aio/pure (* x 2))}))
    }))
    
    (def {result-handle} (sequential-map delayed-double (list 1 2 3)))
    (aio/then result-handle (\ {result} {
      (def {first} (head result))
      (def {second} (head (tail result)))
      (def {third} (head (tail (tail result))))
      (and (== first 2) (and (== second 4) (== third 6)))
    }))
  }))
  (test-async "sequential-map preserves result types" (\ {} {
    ; Mix of different result types
    (def {items} (list 1 2 3))
    (def {result-handle} (sequential-map (\ {x} {
      (if (== x 1)
        {(aio/pure "one")}
        {(if (== x 2)
          {(aio/pure 200)}
          {(aio/pure (list x x x))})})
    }) items))
    
    (aio/then result-handle (\ {result} {
      (def {first} (head result))
      (def {second} (head (tail result)))
      (def {third} (head (tail (tail result))))
      (and (== first "one") 
           (and (== second 200) 
                (== (head third) 3)))
    }))
  }))
  (test-async "sequential-map with nil elements in list" (\ {} {
    (def {result-handle} (sequential-map (\ {x} {(aio/pure x)}) (list nil nil)))
    (aio/then result-handle (\ {result} {
      (def {first} (head result))
      (def {second} (head (tail result)))
      (and (== first nil) (== second nil))
    }))
  }))
  (test-async "sequential-map with larger list" (\ {} {
    (def {items} (list 1 2 3 4 5 6 7 8 9 10))
    (def {result-handle} (sequential-map (\ {x} {(aio/pure (* x x))}) items))
    (aio/then result-handle (\ {result} {
      ; Check first and last elements: 1^2 = 1, 10^2 = 100
      (def {first} (head result))
      ; Get to the 10th element
      (def {last} (nth 10 result))
      (and (== first 1) (== last 100))
    }))
  })))
  {:suite-name "Sequential Map Tests"})
